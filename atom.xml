<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大名Dean鼎</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.deanwangpro.com/"/>
  <updated>2019-02-18T08:17:36.049Z</updated>
  <id>http://www.deanwangpro.com/</id>
  
  <author>
    <name>Dean Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小团队的微服务之路</title>
    <link href="http://www.deanwangpro.com/2019/02/18/road-of-microservice/"/>
    <id>http://www.deanwangpro.com/2019/02/18/road-of-microservice/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-18T08:17:36.049Z</updated>
    
    <content type="html"><![CDATA[<p>微服务是否适合小团队是个见仁见智的问题。回归现象看本质，随着业务复杂度的提高，单体应用越来越庞大，就好像一个类的代码行越来越多，分而治之，切成多个类应该是更好的解决方法，所以一个庞大的单体应用分出多个小应用也更符合这种分治的思想。当然微服务架构不应该是一个小团队一开始就该考虑的问题，而是慢慢演化的结果，谨慎过度设计尤为重要。</p><p>公司的背景是提供SaaS服务，对于大客户也会有定制开发以及私有化部署。经过2年不到的时间，技术架构经历了从单体到微服务再到容器化的过程。</p><a id="more"></a><h1 id="单体应用时代"><a href="#单体应用时代" class="headerlink" title="单体应用时代"></a>单体应用时代</h1><p>早期开发只有两个人，考虑微服务之类的都是多余。不过由于受前公司影响，最初就决定了前后端分离的路线，因为不需要考虑SEO的问题，索性就做成了SPA单页应用。多说一句，前后端分离也不一定就不能服务端渲染，例如电商系统或者一些匿名即可访问的系统，加一层薄薄的View层，无论是php还是用Thymeleaf都是不错的选择。</p><p>部署架构上，我们使用Nginx代理前端HTML资源，在接收请求时根据路径反向代理到server的8080端口实现业务。</p><p><img src="/images/2018-02-18/arch_mono.png" alt=""></p><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p>接口按照标准的Restful来定义，</p><ul><li>版本，统一跟在 /api/后面，例如 <code>/api/v2</code></li><li>以资源为中心，使用复数表述，例如<code>/api/contacts</code>，也可以嵌套，如<code>/api/groups/1/contacts/100</code></li><li>url中尽量不使用动词，实践中发现做到这一点真的比较难，每个研发人员的思路不一致，起的名字也千奇百怪，都需要在代码Review中覆盖。</li><li>动作支持，<code>POST / PUT / DELELE / GET</code> ，这里有一个坑，PUT和PATCH都是更新，但是PUT是全量更新而PATCH是部分更新，前者如果传入的字段是空（未传也视为空）那么也会被更新到数据库中。目前我们虽然是使用PUT但是忽略空字段和未传字段，本质上是一种部分更新，这也带来了一些问题，比如确有置空的业务需要特殊处理。</li><li>接口通过swagger生成文档供前端同事使用。</li></ul><h2 id="持续集成-CI"><a href="#持续集成-CI" class="headerlink" title="持续集成(CI)"></a>持续集成(CI)</h2><p>团队初始成员之前都有在大团队共事的经历，所以对于质量管控和流程管理都有一些共同的要求。因此在开发之初就引入了集成测试的体系，可以直接开发针对接口的测试用例，统一执行并计算覆盖率。</p><p>一般来说代码自动执行的都是单元测试(Unit Test)，我们之所以叫集成测试是因为测试用例是针对API的，并且包含了数据库的读写，MQ的操作等等，除了外部服务的依赖基本都是符合真实生产场景，相当于把Jmeter的事情直接在Java层面做掉了。这在开发初期为我们提供了非常大的便利性。但值得注意的是，由于数据库以及其他资源的引入，数据准备以及数据清理时要考虑的问题就会更多，例如如何控制并行任务之间的测试数据互不影响等等。</p><p>为了让这一套流程可以自动化的运作起来， 引入Jenkins也是理所当然的事情了。</p><p><img src="/images/2018-02-18/ci_mono.png" alt=""></p><p>开发人员提交代码进入gerrit中，Jenkins被触发开始编译代码并执行集成测试，完成后生成测试报告，测试通过再由reviewer进行代码review。在单体应用时代这样的CI架构已经足够好用，由于有集成测试的覆盖，在保持API兼容性的前提下进行代码重构都会变得更有信心。</p><h1 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h1><h2 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h2><p>从数据层面看，最简单的方式就是看数据库的表之间是否有比较少的关联。例如最容易分离的一般来说都是用户管理模块。如果从领域驱动设计（DDD）看，其实一个服务就是一个或几个相关联的领域模型，通过少量数据冗余划清服务边界。单个服务内通过领域服务完成多个领域对象协作。当然DDD比较复杂，要求领域对象设计上是充血模型而非贫血模型。从实践角度讲，充血模型对于大部分开发人员来说难度非常高，什么代码应该属于行为，什么属于领域服务，很多时候非常考验人员水平。</p><p>服务拆分是一个大工程，往往需要几个对业务以及数据最熟悉的人一起讨论，甚至要考虑到团队结构，最终的效果是服务边界清晰， 没有环形依赖和避免双向依赖。</p><h2 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h2><p>由于之前的单体服务使用的是spring boot，所以框架自然而的选择了spring cloud。其实个人认为微服务框架不应该限制技术与语言，但生产实践中发现无论dubbo还是spring cloud都具有侵入性，我们在将nodejs应用融入spring cloud体系时就发现了许多问题。也许未来的service mesh才是更合理的发展道路。</p><p><img src="/images/2018-02-18/arch_spring_cloud.png" alt=""></p><p>这是典型的Spring Cloud的使用方法，该图取自<a href="https://mp.weixin.qq.com/s/vnWXpH5pv-FAzLZfbgTGvg" target="_blank" rel="noopener">纯洁的微笑公众号</a></p><ul><li>zuul作为gateway，分发不同客户端的请求到具体service</li><li>erueka作为注册中心，完成了服务发现和服务注册</li><li>每个service包括gateway都自带了Hystrix提供的限流和熔断功能</li><li>service之间通过feign和ribbon互相调用，feign实际上是屏蔽了service对erueka的操作</li></ul><p>上文说的一旦要融入异构语言的service，那么服务注册，服务发现，服务调用，熔断和限流都需要自己处理。再有关于zuul要多说几句，Sprin Cloud提供的zuul对Netflix版本的做了裁剪，去掉了动态路由功能（Groovy实现），另外一点就是zuul的性能一般，由于采用同步编程模型，对于IO密集型等后台处理时间长的链路非常容易将servlet的线程池占满，所以如果将zuul与主要service放置在同一台物理机上，在流量大的情况下，zuul的资源消耗非常大。实际测试也发现经过zuul与直接调用service的性能损失在30%左右，并发压力大时更为明显。现在spring cloud gateway是pivotal的主推了，支持异步编程模型，后续架构优化也许会采用，或是直接使用Kong这种基于nginx的网关来提供性能。当然同步模型也有优点，编码更简单，后文将会提到使用ThreadLocal如何建立链路跟踪。</p><h2 id="架构改造"><a href="#架构改造" class="headerlink" title="架构改造"></a>架构改造</h2><p>经过大半年的改造以及新需求的加入，单体服务被不断拆分，最终形成了10余个微服务，并且搭建了Spark用于BI。初步形成两大体系，微服务架构的在线业务系统(OLTP) + Spark大数据分析系统(OLAP)。数据源从只有Mysql增加到了ES和Hive。多数据源之间的数据同步也是值得一说的话题，但内容太多不在此文赘述。</p><p><img src="/images/2018-02-18/arch_microservice.png" alt=""></p><p>服务拆分我们采用直接割接的方式，数据表也是整体迁移。因为几次大改造的升级申请了停服，所以步骤相对简单。如果需要不停服升级，那么应该采用先双写再逐步切换的方式保证业务不受影响。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>与CI比起来，持续交付（CD）实现更为复杂，在资源不足的情况我们尚未实现CD，只是实现执行了自动化部署。</p><p>由于生产环境需要通过跳板机操作，所以我们通过Jenkins生成jar包传输到跳板机，之后再通过Ansible部署到集群。</p><p><img src="/images/2018-02-18/ci_microservice.png" alt=""></p><p>简单粗暴的部署方式在小规模团队开发时还是够用的，只是需要在部署前保证测试（人工测试 + 自动化测试）到位。</p><h2 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h2><p>开源的全链路跟踪很多，比如spring cloud sleuth + zipkin，国内有美团的CAT等等。其目的就是当一个请求经过多个服务时，可以通过一个固定值获取整条请求链路的行为日志，基于此可以再进行耗时分析等，衍生出一些性能诊断的功能。不过对于我们而言，首要目的就是trouble shooting，出了问题需要快速定位异常出现在什么服务，整个请求的链路是怎样的。</p><p>为了让解决方案轻量，我们在日志中打印RequestId以及TraceId来标记链路。RequestId在gateway生成表示唯一一次请求，TraceId相当于二级路径，一开始与RequestId一样，但进入线程池或者消息队列后，TraceId会增加标记来标识唯一条路径。举个例子，当一次请求会向MQ发送一个消息，那么这个消息可能会被多个消费者消费，此时每个消费线程都会自己生成一个TraceId来标记消费链路。加入TraceId的目的就是为了避免只用RequestId过滤出太多日志。实现如图所示，</p><p><img src="/images/2018-02-18/seq_trace.png" alt=""></p><p>简单的说，通过ThreadLocal存放APIRequestContext串联单服务内的所有调用，当跨服务调用时，将APIRequestContext信息转化为Http Header，被调用方获取到Http Header后再次构建APIRequestContext放入ThreadLocal，重复循环保证RequestId和TraceId不丢失即可。如果进入MQ，那么APIRequestContext信息转化为Message Header即可（基于Rabbitmq实现）。</p><p>当日志汇总到日志系统后，如果出现问题，只需要捕获发生异常的RequestId或是TraceId即可进行问题定位</p><p><img src="/images/2018-02-18/graylog_trace.png" alt=""></p><p>经过一年来的使用，基本可以满足绝大多数trouble shooting的场景，一般半小时内即可定位到具体业务。</p><h2 id="运维监控"><a href="#运维监控" class="headerlink" title="运维监控"></a>运维监控</h2><p>在容器化之前，采用telegraf + influxdb + grafana的方案。telegraf作为探针收集jvm，system，mysql等资源的信息，写入influxdb，最终通过grafana做数据可视化。spring boot actuator可以配合jolokia暴露jvm的endpoint。整个方案零编码，只需要花时间配置。</p><h1 id="容器化时代"><a href="#容器化时代" class="headerlink" title="容器化时代"></a>容器化时代</h1><h2 id="架构改造-1"><a href="#架构改造-1" class="headerlink" title="架构改造"></a>架构改造</h2><p>因为在做微服务之初就计划了容器化，所以架构并未大动，只是每个服务都会建立一个Dockerfile用于创建docker image</p><p><img src="/images/2018-02-18/arch_docker.png" alt=""></p><p>涉及变化的部分包括：</p><ol><li>CI中多了构建docker image的步骤</li><li>自动化测试过程中将数据库升级从应用中剥离单独做成docker image</li><li>生产中用k8s自带的service替代了eruka</li></ol><p>理由下文一一道来。</p><h2 id="Spring-Cloud与k8s的融合"><a href="#Spring-Cloud与k8s的融合" class="headerlink" title="Spring Cloud与k8s的融合"></a>Spring Cloud与k8s的融合</h2><p>我们使用的是Redhat的Openshift，可以认为是k8s企业版，其本身就有service的概念。一个service下有多个pod，pod内即是一个可服务单元。service之间互相调用时k8s会提供默认的负载均衡控制，发起调用方只需要写被调用方的serviceId即可。这一点和spring cloud fegin使用ribbon提供的功能如出一辙。也就是说服务治理可以通过k8s来解决，那么为什么要替换呢？其实上文提到了，Spring Cloud技术栈对于异构语言的支持问题，我们有许多BFF（Backend for Frontend）是使用nodejs实现的，这些服务要想融合到Spring Cloud中，服务注册，负载均衡，心跳检查等等都要自己实现。如果以后还有其他语言架构的服务加入进来，这些轮子又要重造。基于此类原因综合考量后，决定采用Openshift所提供的网络能力替换eruka。</p><p>由于本地开发和联调过程中依然依赖eruka，所以只在生产上通过配置参数来控制，</p><ul><li><code>eureka.client.enabled</code> 设置为 <code>false</code>，停止各服务的eureka注册</li><li><code>ribbon.eureka.enabled</code> 设置为 <code>false</code>，让ribbon不从eureka获取服务列表</li><li>以服务foo为例，<code>foo.ribbon.listofservers</code> 设置为 <a href="http://foo:8080" target="_blank" rel="noopener"><code>http://foo:8080</code></a>，那么当一个服务需要使用服务foo的时候，就会直接调用到<a href="http://foo:8080" target="_blank" rel="noopener"><code>http://foo:8080</code></a></li></ul><h2 id="CI的改造"><a href="#CI的改造" class="headerlink" title="CI的改造"></a>CI的改造</h2><p>CI的改造主要是多了一部编译docker image并打包到Harbor的过程，部署时会直接从Harbor拉取镜像。另一个就是数据库的升级工具。之前我们使用flyway作为数据库升级工具，当应用启动时自动执行SQL脚本。随着服务实例越来越多，一个服务的多个实例同时升级的情况也时有发生，虽然flyway是通过数据库锁实现了升级过程不会有并发，但会导致被锁服务启动时间变长的问题。从实际升级过程来看，将可能发生的并发升级变为单一进程可能更靠谱。此外后期分库分表的架构也会使随应用启动自动升级数据库变的困难。综合考量，我们将升级任务做了拆分，每个服务都有自己的升级项目并会做容器化。在使用时，作为run once的工具来使用，即<code>docker run -rm</code>的方式。并且后续也支持了设定目标版本的功能，在私有化项目的跨版本升级中起到了非常好的效果。</p><p>至于自动部署，由于服务之间存在上下游关系，例如config，eruka等属于基本服务被其他服务依赖，部署也产生了先后顺序。基于Jenkins做pipeline可以很好的解决这个问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实以上的每一点都可以深入的写成一篇文章，微服务的架构演进涉及到开发，测试和运维，要求团队内多工种紧密合作。分治是软件行业解决大系统的不二法门，作为小团队我们并没有盲目追新，而是在发展的过程通过服务化的方式解决问题。从另一方面我们也体会到了微服务对于人的要求，以及对于团队的挑战都比过去要高要大。未来仍需探索，演进仍在路上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务是否适合小团队是个见仁见智的问题。回归现象看本质，随着业务复杂度的提高，单体应用越来越庞大，就好像一个类的代码行越来越多，分而治之，切成多个类应该是更好的解决方法，所以一个庞大的单体应用分出多个小应用也更符合这种分治的思想。当然微服务架构不应该是一个小团队一开始就该考虑的问题，而是慢慢演化的结果，谨慎过度设计尤为重要。&lt;/p&gt;
&lt;p&gt;公司的背景是提供SaaS服务，对于大客户也会有定制开发以及私有化部署。经过2年不到的时间，技术架构经历了从单体到微服务再到容器化的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring-cloud" scheme="http://www.deanwangpro.com/tags/spring-cloud/"/>
    
      <category term="ci" scheme="http://www.deanwangpro.com/tags/ci/"/>
    
      <category term="microservice" scheme="http://www.deanwangpro.com/tags/microservice/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.1.2 &amp; Spring Cloud Greenwich 升级记录</title>
    <link href="http://www.deanwangpro.com/2019/02/02/spring-boot-cloud-geenwich-upgrade/"/>
    <id>http://www.deanwangpro.com/2019/02/02/spring-boot-cloud-geenwich-upgrade/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-02T11:29:27.066Z</updated>
    
    <content type="html"><![CDATA[<p>节前没有新业务代码，正好Greenwich刚发布，于是开始为期四天的框架代码升级。</p><p>之前的版本是 spring boot 1.5.10 , spring cloud Edgware.SR3</p><a id="more"></a><h2 id="依赖升级"><a href="#依赖升级" class="headerlink" title="依赖升级"></a>依赖升级</h2><ul><li>增加依赖管理插件 <code>apply plugin: &#39;io.spring.dependency-management&#39;</code></li><li>spring-cloud-starter-eureka → spring-cloud-starter-netflix-eureka-client</li><li>spring-cloud-starter-feign → spring-cloud-starter-openfeign</li><li>gradle版本要求4.4</li></ul><h2 id="boot-spring-boot-starter-data-jpa"><a href="#boot-spring-boot-starter-data-jpa" class="headerlink" title="boot : spring-boot-starter-data-jpa"></a>boot : spring-boot-starter-data-jpa</h2><ul><li>delete → deleteById</li><li><p>findone → findById</p><p>  这个改动确实大，返回值变成了Optional，合理是合理的，只改的真多。。</p></li></ul><h2 id="boot-spring-boot-starter-data-redis"><a href="#boot-spring-boot-starter-data-redis" class="headerlink" title="boot : spring-boot-starter-data-redis"></a>boot : spring-boot-starter-data-redis</h2><p>Jedis → Lettuce</p><p>还好并没有使用它的autoconfiguration，配置上有一个小坑，Jedis的redis.timeout是表示connection timeout, 而Lettuce是表示command timeout，之前配置成0的，如果set到Lettuce的commandtimeout里面那就要抛异常了。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置:"></a>配置<strong>:</strong></h2><p>可以在build.gradle中加入，启动时会检查配置是否兼容</p><pre><code>compile &quot;org.springframework.boot:spring-boot-properties-migrator&quot; </code></pre><p><strong>注意：完成迁移后需要删除</strong></p><p><img src="/images/springboot-prop-migrator.png" alt="migrator"></p><p>警告如上图会告知最新的配置格式</p><h2 id="boot-spring-boot-starter-actuator"><a href="#boot-spring-boot-starter-actuator" class="headerlink" title="boot: spring-boot-starter-actuator"></a>boot: spring-boot-starter-actuator</h2><p>endpoint的暴露方式变化，<code>management.endpoints.web.exposure.include = &quot;*&quot;</code> 表示暴露所有endpoints，如果配置了security那么也需要在security的配置中开放访问<code>/actuator</code>路径</p><h2 id="boot-spring-boot-starter-security"><a href="#boot-spring-boot-starter-security" class="headerlink" title="boot: spring-boot-starter-security"></a>boot: spring-boot-starter-security</h2><p>自动注入的<code>AuthenticationManager</code>可能会找不到</p><p>If you want to expose Spring Security’s <code>AuthenticationManager</code> as a bean, override the <code>authenticationManagerBean</code> method on your <code>WebSecurityConfigurerAdapter</code> and annotate it with <code>@Bean</code>.</p><h2 id="cloud-eureka"><a href="#cloud-eureka" class="headerlink" title="cloud : eureka"></a>cloud : eureka</h2><p>各个项目在注册中心里面的客户端实例IP显示不正确，需要修改每个项目的</p><p><strong>bootstarp.yml</strong> </p><ul><li>${spring.cloud.client.ipAddress} → ${spring.cloud.client.ip-address}</li></ul><h2 id="boot-spring-boot-starter-test"><a href="#boot-spring-boot-starter-test" class="headerlink" title="boot: spring-boot-starter-test:"></a>boot: spring-boot-starter-test<strong>:</strong></h2><ul><li>org.mockito.Matchers → org.mockito.ArgumentMatchers 注意build时的warning</li><li>Mock方法时请使用Mocikto.doReturn(…).when(…)，不使用when(…).thenReturn(…)，否则<code>@spybean</code>的会调用实际方法</li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>版本升级后会有deprecated的类或方法，所以要注意看console中build的warning信息</li><li><p>由于spring cloud依赖管理插件强制cuator升级到4.0.1，导致我们使用的elestic-job不能正常工作，只能强行控制版本。</p><pre><code>dependencyManagement {    imports {        mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:${SPRING_CLOUD_VERSION}&quot;    }    dependencies {        dependency &apos;org.apache.curator:curator-framework:2.10.0&apos;        dependency &apos;org.apache.curator:curator-recipes:2.10.0&apos;        dependency &apos;org.apache.curator:curator-client:2.10.0&apos;    }}</code></pre></li><li><p>如果启用出现error，报bean重复，首先确认是不是故意覆盖，如重写spring-boot自带的bean，如是，可以在bootstrap.yml加入</p><pre><code>spring.main.allow-bean-definition-overriding=true</code></pre></li><li><p>FeignClient注解增加了contextId属性</p><pre><code>@FeignClient(value = &quot;foo&quot;, contextId = &quot;fooFeign&quot;)</code></pre><p> 此contextId即表示bean id，所有注入使用时需要</p><pre><code>@AutowriedFooFeign fooFeign</code></pre><p> 如果不写contextId，当多个class都是@FeignClient(“foo”)，即会认为是同一个bean而排除上一条所说的warning</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节前没有新业务代码，正好Greenwich刚发布，于是开始为期四天的框架代码升级。&lt;/p&gt;
&lt;p&gt;之前的版本是 spring boot 1.5.10 , spring cloud Edgware.SR3&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring-boot" scheme="http://www.deanwangpro.com/tags/spring-boot/"/>
    
      <category term="spring-cloud" scheme="http://www.deanwangpro.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq的性能测试</title>
    <link href="http://www.deanwangpro.com/2018/10/04/rabbitmq-performance/"/>
    <id>http://www.deanwangpro.com/2018/10/04/rabbitmq-performance/</id>
    <published>2018-10-03T16:00:00.000Z</published>
    <updated>2018-10-05T03:30:14.898Z</updated>
    
    <content type="html"><![CDATA[<p>在做系统的整体性能测试时发现经常会卡在一个较低的QPS（单机低于100）数值，而且应用服务器的负载不高，检查MQ消费速率只有40左右。接着把目标放在消息发送端上，发现消息发送速率很低，大约40条/s。</p><p>果断搭建一个最小化工程单测Rabbitmq发送性能，发现在启用发送端事务后性能下降非常明显。</p><table><thead><tr><th>消息数量</th><th>开启事务</th><th>未开启事务</th></tr></thead><tbody><tr><td>10w</td><td>320796ms</td><td>10246ms</td></tr></tbody></table><p>本机SSD硬盘测试结果10w条消息未开启事务，大约10s发送完毕；而开启了事务后，需要将近320s，差了30多倍。</p><p>接着翻阅Rabbitmq官网，发现开启事务性能最大损失超过250倍。</p><blockquote><p>Using standard AMQP 0-9-1, the only way to guarantee that a message isn’t lost is by using transactions – make the channel transactional then for each message or set of messages publish, commit. In this case, transactions are unnecessarily heavyweight and decrease throughput by a factor of 250. To remedy this, a confirmation mechanism was introduced. It mimics the consumer acknowledgements mechanism already present in the protocol.</p></blockquote><a id="more"></a><h3 id="事务为什么会慢"><a href="#事务为什么会慢" class="headerlink" title="事务为什么会慢"></a>事务为什么会慢</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>该标志位开启后表示Rabbitmq的发送统一被spring事务管理。当一段代码被<code>@Transactional</code>包裹，那么只有当事务结束后，消息才会正在的发送到Rabbitmq的exchange中。具体代码详见<code>rabbitTemplate.java</code>中的<code>doSend()</code>。</p><p>事务机制是Rabbitmq自身支持的，原理是<code>channel.txSelect()</code>开启事务，<code>channel.txRollback()</code>回滚事务。<code>channel.txCommit()</code>提交事务。当事务开启后，通过抓包会发现网络交互增多。</p><p><img src="/images/2018-10-04/rabbitmq_tx.jpg" alt="rabbitmq_tx"></p><h3 id="是否可以去掉事务呢？"><a href="#是否可以去掉事务呢？" class="headerlink" title="是否可以去掉事务呢？"></a>是否可以去掉事务呢？</h3><p>实践证明，<strong>不行</strong>。</p><p>因为某些消息，特别是实体的新增或者更新消息发出后，消费者有可能会通过API反查，这时如果生产者本地事务未提交。消费者就有可能消费到空数据或者旧数据。所以生产者必须将发送消息的事务包裹在本地数据库事务当中。</p><p>在过去的实践中，有一种解法可以在不开启事务的情况下解决这个问题，就是利用本地消息表，即生产者调用后不发送，而是将消息写入到本地消息表，当事务失败那么此次写入操作也会回滚。真正发送消息到MQ就开启另一个定时线程轮询该本地消息表异步发送消息。这种方法理论上可行，但实际操作非常复杂，当有多个生产者实例时，定时发送线程也会有多个，那么就会遇到各种并发问题。</p><h3 id="最大限度改善性能"><a href="#最大限度改善性能" class="headerlink" title="最大限度改善性能"></a>最大限度改善性能</h3><p>既然无法去除事务，并且也不希望代码异常复杂。那么可以将消息分为两类，一类是changlog即实体的变化，一类是command，即通知消费者可以开始做某事，通常用在同步转异步的场景。对于第一类消息仍然保留事务，对于第二类消息关闭发送事务，采用PublisherConfirm的方式保证消息发送成功。</p><p>再次测试，性能明显提高，但是并未达到预期，通过<code>innotop</code>命令查看MySQL压力，发现只有10K/s上下。检查Rabbitmq所在机器的负载。</p><p><img src="/images/2018-10-04/high_iowa.png" alt="high_iowa"></p><p>iowait非常高，由于该机器上还装有es，同样是io密集型的应用，所以实际性能瓶颈都在磁盘io上了。</p><p>跟Devops确认了机器情况，这台机器恰好是Rabbitmq的磁盘节点。为了快速验证，新增了一块SSD硬盘并将Rabbitmq消息文件都挂载到新加的磁盘上。再次测试，iowait下降明显。</p><p><img src="/images/2018-10-04/low_iowa.png" alt="low_iowa"></p><p>通过<code>innotop</code>命令查看MySQL压力，发现上升了一倍，达到20K/s。基本上把压力都转到了数据库一侧。系统整体性能提升了一个数量级。也许该Rabbitmq节点独占一台机器效果会更好。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能优化有时候就像破案，看了jstat没问题，gc没问题，机器负载也不高，就是抓不到“元凶”。需要一点一点的扣，往往一个短板就造成了木桶效应。另外还有一点就是如果硬件能够解决的事情，就不要过度优化软件了，代码复杂度上升往往意味着更多的BUG，在资源有限的情况下多花点钱省点时间还是值得的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做系统的整体性能测试时发现经常会卡在一个较低的QPS（单机低于100）数值，而且应用服务器的负载不高，检查MQ消费速率只有40左右。接着把目标放在消息发送端上，发现消息发送速率很低，大约40条/s。&lt;/p&gt;
&lt;p&gt;果断搭建一个最小化工程单测Rabbitmq发送性能，发现在启用发送端事务后性能下降非常明显。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;消息数量&lt;/th&gt;
&lt;th&gt;开启事务&lt;/th&gt;
&lt;th&gt;未开启事务&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10w&lt;/td&gt;
&lt;td&gt;320796ms&lt;/td&gt;
&lt;td&gt;10246ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;本机SSD硬盘测试结果10w条消息未开启事务，大约10s发送完毕；而开启了事务后，需要将近320s，差了30多倍。&lt;/p&gt;
&lt;p&gt;接着翻阅Rabbitmq官网，发现开启事务性能最大损失超过250倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using standard AMQP 0-9-1, the only way to guarantee that a message isn’t lost is by using transactions – make the channel transactional then for each message or set of messages publish, commit. In this case, transactions are unnecessarily heavyweight and decrease throughput by a factor of 250. To remedy this, a confirmation mechanism was introduced. It mimics the consumer acknowledgements mechanism already present in the protocol.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="performance" scheme="http://www.deanwangpro.com/tags/performance/"/>
    
      <category term="tuning" scheme="http://www.deanwangpro.com/tags/tuning/"/>
    
      <category term="rabbitmq" scheme="http://www.deanwangpro.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud服务网关中的Timeout设置</title>
    <link href="http://www.deanwangpro.com/2018/04/13/zuul-hytrix-ribbon-timeout/"/>
    <id>http://www.deanwangpro.com/2018/04/13/zuul-hytrix-ribbon-timeout/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-13T08:59:51.051Z</updated>
    
    <content type="html"><![CDATA[<p>大家在初次使用spring-cloud的gateway的时候，肯定会被里面各种的Timeout搞得晕头转向。hytrix有设置，ribbon也有。我们一开始也是乱设一桶，Github上各种项目里也没几个设置正确的。对Timeout的研究源于一次log中的warning</p><blockquote><p>The Hystrix timeout of 60000 ms for the command “foo” is set lower than the combination of the Ribbon read and connect timeout, 200000ms.</p></blockquote><a id="more"></a><h3 id="hytrix超时时间"><a href="#hytrix超时时间" class="headerlink" title="hytrix超时时间"></a>hytrix超时时间</h3><p>log出自<code>AbstractRibbonCommand.java</code>，那么索性研究一下源码。</p><p>假设：</p><ul><li>这里gateway会请求一个serviceName=foo的服务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHystrixTimeout</span><span class="params">(IClientConfig config, String commandKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ribbonTimeout = getRibbonTimeout(config, commandKey);</span><br><span class="line">DynamicPropertyFactory dynamicPropertyFactory = DynamicPropertyFactory.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取默认的hytrix超时时间</span></span><br><span class="line"><span class="keyword">int</span> defaultHystrixTimeout = dynamicPropertyFactory.getIntProperty(<span class="string">"hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds"</span>,</span><br><span class="line"><span class="number">0</span>).get();</span><br><span class="line"><span class="comment">// 获取具体服务的hytrix超时时间，这里应该是hystrix.command.foo.execution.isolation.thread.timeoutInMilliseconds</span></span><br><span class="line"><span class="keyword">int</span> commandHystrixTimeout = dynamicPropertyFactory.getIntProperty(<span class="string">"hystrix.command."</span> + commandKey + <span class="string">".execution.isolation.thread.timeoutInMilliseconds"</span>,</span><br><span class="line"><span class="number">0</span>).get();</span><br><span class="line"><span class="keyword">int</span> hystrixTimeout;</span><br><span class="line"><span class="comment">// hystrixTimeout的优先级是 具体服务的hytrix超时时间 &gt; 默认的hytrix超时时间 &gt; ribbon超时时间</span></span><br><span class="line"><span class="keyword">if</span>(commandHystrixTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">hystrixTimeout = commandHystrixTimeout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(defaultHystrixTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">hystrixTimeout = defaultHystrixTimeout;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">hystrixTimeout = ribbonTimeout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果默认的或者具体服务的hytrix超时时间小于ribbon超时时间就会警告</span></span><br><span class="line"><span class="keyword">if</span>(hystrixTimeout &lt; ribbonTimeout) &#123;</span><br><span class="line">LOGGER.warn(<span class="string">"The Hystrix timeout of "</span> + hystrixTimeout + <span class="string">"ms for the command "</span> + commandKey +</span><br><span class="line"><span class="string">" is set lower than the combination of the Ribbon read and connect timeout, "</span> + ribbonTimeout + <span class="string">"ms."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hystrixTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着，看一下我们的配置是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 60000</span><br><span class="line">            </span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: 50000</span><br><span class="line">  ConnectTimeout: 50000</span><br><span class="line">  MaxAutoRetries: 0</span><br><span class="line">  MaxAutoRetriesNextServer: 1</span><br></pre></td></tr></table></figure><h3 id="ribbon超时时间"><a href="#ribbon超时时间" class="headerlink" title="ribbon超时时间"></a>ribbon超时时间</h3><p>这里ribbon的超时时间是50000ms，那么为什么log中写的ribbon时间是200000ms?</p><p>继续分析源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRibbonTimeout</span><span class="params">(IClientConfig config, String commandKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ribbonTimeout;</span><br><span class="line"><span class="comment">// 这是比较异常的情况，不说</span></span><br><span class="line"><span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">ribbonTimeout = RibbonClientConfiguration.DEFAULT_READ_TIMEOUT + RibbonClientConfiguration.DEFAULT_CONNECT_TIMEOUT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 这里获取了四个参数，ReadTimeout，ConnectTimeout，MaxAutoRetries， MaxAutoRetriesNextServer</span></span><br><span class="line"><span class="keyword">int</span> ribbonReadTimeout = getTimeout(config, commandKey, <span class="string">"ReadTimeout"</span>,</span><br><span class="line">IClientConfigKey.Keys.ReadTimeout, RibbonClientConfiguration.DEFAULT_READ_TIMEOUT);</span><br><span class="line"><span class="keyword">int</span> ribbonConnectTimeout = getTimeout(config, commandKey, <span class="string">"ConnectTimeout"</span>,</span><br><span class="line">IClientConfigKey.Keys.ConnectTimeout, RibbonClientConfiguration.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line"><span class="keyword">int</span> maxAutoRetries = getTimeout(config, commandKey, <span class="string">"MaxAutoRetries"</span>,</span><br><span class="line">IClientConfigKey.Keys.MaxAutoRetries, DefaultClientConfigImpl.DEFAULT_MAX_AUTO_RETRIES);</span><br><span class="line"><span class="keyword">int</span> maxAutoRetriesNextServer = getTimeout(config, commandKey, <span class="string">"MaxAutoRetriesNextServer"</span>,</span><br><span class="line">IClientConfigKey.Keys.MaxAutoRetriesNextServer, DefaultClientConfigImpl.DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER);</span><br><span class="line"><span class="comment">// 原来ribbonTimeout的计算方法在这里，以上文的设置为例</span></span><br><span class="line"><span class="comment">// ribbonTimeout = (50000 + 50000) * (0 + 1) * (1 + 1) = 200000</span></span><br><span class="line">ribbonTimeout = (ribbonReadTimeout + ribbonConnectTimeout) * (maxAutoRetries + <span class="number">1</span>) * (maxAutoRetriesNextServer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ribbonTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ribbonTimeout是一个总时间，所以从逻辑上来讲，作者希望hystrixTimeout要大于ribbonTimeout，否则hystrix熔断了以后，ribbon的重试就都没有意义了。</p><h3 id="ribbon单服务设置"><a href="#ribbon单服务设置" class="headerlink" title="ribbon单服务设置"></a>ribbon单服务设置</h3><p>到这里最前面的疑问已经解开了，但是hytrix可以分服务设置timeout，ribbon可不可以? 源码走起，这里看的文件是<code>DefaultClientConfigImpl.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是获取配置的入口方法，如果是null，那么用默认值</span></span><br><span class="line"><span class="comment">// 所有ribbon的默认值的都在该类中设置了，可以自己看一下</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(IClientConfigKey&lt;T&gt; key, T defaultValue)</span> </span>&#123;</span><br><span class="line">    T value = get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是核心方法   </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableDynamicProperties) &#123;</span><br><span class="line">        String dynamicValue = <span class="keyword">null</span>;</span><br><span class="line">        DynamicStringProperty dynamicProperty = dynamicProperties.get(key);</span><br><span class="line">        <span class="comment">// dynamicProperties其实是一个缓存，首次访问foo服务的时候会加载</span></span><br><span class="line">        <span class="keyword">if</span> (dynamicProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynamicValue = dynamicProperty.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存没有，那么就再获取一次，注意这里的getConfigKey(key)是生成key的方法</span></span><br><span class="line">        <span class="keyword">if</span> (dynamicValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynamicValue = DynamicProperty.getInstance(getConfigKey(key)).getString();</span><br><span class="line">            <span class="comment">// 如果还是没有取默认值，getDefaultPropName(key)生成key的方法</span></span><br><span class="line">            <span class="keyword">if</span> (dynamicValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dynamicValue = DynamicProperty.getInstance(getDefaultPropName(key)).getString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dynamicValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dynamicValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> properties.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以我们的服务为例：<br><code>getConfigKey(key)</code> returns <code>foo.ribbon.ReadTimeout</code><br><code>getDefaultPropName(key)</code> returns <code>ribbon.ReadTimeout</code></p><p>一目了然，<code>{serviceName}.ribbon.{propertyName}</code>就可以了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>感觉ribbon和hytrix的配置获取源码略微有点乱，所以也导致大家在设置的时候有些无所适从。<code>spring-cloud</code>的代码一直在迭代，无论github上还是文档可能都相对滞后，这时候阅读源码并且动手debug一下是最能接近事实真相的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在初次使用spring-cloud的gateway的时候，肯定会被里面各种的Timeout搞得晕头转向。hytrix有设置，ribbon也有。我们一开始也是乱设一桶，Github上各种项目里也没几个设置正确的。对Timeout的研究源于一次log中的warning&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Hystrix timeout of 60000 ms for the command “foo” is set lower than the combination of the Ribbon read and connect timeout, 200000ms.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://www.deanwangpro.com/tags/spring/"/>
    
      <category term="spring-cloud" scheme="http://www.deanwangpro.com/tags/spring-cloud/"/>
    
      <category term="timeout" scheme="http://www.deanwangpro.com/tags/timeout/"/>
    
      <category term="ribbon" scheme="http://www.deanwangpro.com/tags/ribbon/"/>
    
      <category term="hytrix" scheme="http://www.deanwangpro.com/tags/hytrix/"/>
    
  </entry>
  
  <entry>
    <title>spring-cloud中zuul的两种隔离机制实验</title>
    <link href="http://www.deanwangpro.com/2018/04/04/spring-cloud-zuul-threads/"/>
    <id>http://www.deanwangpro.com/2018/04/04/spring-cloud-zuul-threads/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-04T10:39:13.231Z</updated>
    
    <content type="html"><![CDATA[<p>ZuulException REJECTED_SEMAPHORE_EXECUTION 是一个最近在性能测试中经常遇到的异常。查询资料发现是因为zuul默认每个路由直接用信号量做隔离，并且默认值是100，也就是当一个路由请求的信号量高于100那么就拒绝服务了，返回500。</p><a id="more"></a><h3 id="信号量隔离"><a href="#信号量隔离" class="headerlink" title="信号量隔离"></a>信号量隔离</h3><p>既然默认值太小，那么就在gateway的配置提高各个路由的信号量再实验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">routes:</span><br><span class="line">    linkflow:</span><br><span class="line">      path: /api1/**</span><br><span class="line">      serviceId: lf</span><br><span class="line">      stripPrefix: false</span><br><span class="line">      semaphore:</span><br><span class="line">        maxSemaphores: 2000</span><br><span class="line">    oauth:</span><br><span class="line">      path: /api2/**</span><br><span class="line">      serviceId: lf</span><br><span class="line">      stripPrefix: false</span><br><span class="line">      semaphore:</span><br><span class="line">        maxSemaphores: 1000</span><br></pre></td></tr></table></figure><p>两个路由的信号量分开提高到2000和1000。我们再用gatling测试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setUp(scn.inject(rampUsers(200) over (3 seconds)).protocols(httpConf))</span><br></pre></td></tr></table></figure><p>这是我们的模型，3s内启动200个用户，顺序访问5个API。所以会有1000个request。机器配置只有2核16G，并且是docker化的数据库。所以整体性能不高。</p><p><img src="/images/15228346573506.jpg" alt="信号量统计"></p><p>看结果仍然有57个KO，但是比之前1000个Request有900个KO的比例好很多了。</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p><code>Edgware</code>版本的spring cloud提供了另一种基于线程池的隔离机制。实现起来也非常简单，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  ribbon-isolation-strategy: THREAD</span><br><span class="line">  thread-pool:</span><br><span class="line">    use-separate-thread-pools: true</span><br><span class="line">    thread-pool-key-prefix: zuulgw</span><br><span class="line">    </span><br><span class="line">hystrix:</span><br><span class="line">  threadpool:</span><br><span class="line">    default:</span><br><span class="line">      coreSize: 50</span><br><span class="line">      maximumSize: 10000</span><br><span class="line">      allowMaximumSizeToDivergeFromCoreSize: true</span><br><span class="line">      maxQueueSize: -1</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 60000</span><br></pre></td></tr></table></figure><p><code>use-separate-thread-pools</code>的意思是每个路由都有自己的线程池，而不是共享一个。<br><code>thread-pool-key-prefix</code>会指定一个线程池前缀方便调试。<br><code>hystrix</code>的部分主要设置线程池的大小，这里设置了10000，其实并不是越大越好。线程池越大削峰填谷的效果越显著，也就是时间换空间。系统的整体负载会上升，导致响应时间越来越长，那么当响应时间超过某个限度，其实系统也算是不可用了。后面可以看到数据。</p><p><img src="/images/15228360753126.jpg" alt="线程池统计"></p><p>这次没有500的情况了，1000个Request都正常返回了。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>从几张图对比下两种隔离的效果，上图是信号量隔离，下图是线程隔离。</p><h4 id="响应时间分布"><a href="#响应时间分布" class="headerlink" title="响应时间分布"></a>响应时间分布</h4><p><img src="/images/15228364522331.jpg" alt="信号量隔离响应时间分布"></p><p><img src="/images/15228364349973.jpg" alt="线程隔离响应时间分布"></p><p>直观上能发现使用线程隔离的分布更好看一些，600ms内的响应会更多一些。</p><h4 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h4><p><img src="/images/15228368284029.jpg" alt="信号量隔离QPS"></p><p><img src="/images/15228368551165.jpg" alt="线程隔离QPS"></p><p>两张图展示的是同一时刻的Request和Response的数量。</p><p>先看信号量隔离的场景，Response per second是逐步提升的，但是达到一个量级后，gateway开始拒绝服务。猜测是超过了信号量的限制或是超时？</p><p>线程隔离的这张就比较有意思了，可以看到Request per second上升的速度要比上面的快，说明系统是试图接收更多的请求然后分发给线程池。再看在某个时间点Response per second反而开始下降，因为线程不断的创建消耗了大量的系统资源，响应变慢。之后因为请求少了，负载降低，Response又开始抬升。所以线程池也并非越大越好，需要不断调试寻找一个平衡点。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>线程池提供了比信号量更好的隔离机制，并且从实际测试发现高吞吐场景下可以完成更多的请求。但是信号量隔离的开销更小，对于本身就是10ms以内的系统，显然信号量更合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZuulException REJECTED_SEMAPHORE_EXECUTION 是一个最近在性能测试中经常遇到的异常。查询资料发现是因为zuul默认每个路由直接用信号量做隔离，并且默认值是100，也就是当一个路由请求的信号量高于100那么就拒绝服务了，返回500。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://www.deanwangpro.com/tags/spring/"/>
    
      <category term="test" scheme="http://www.deanwangpro.com/tags/test/"/>
    
      <category term="spring-cloud" scheme="http://www.deanwangpro.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot系列之集成测试</title>
    <link href="http://www.deanwangpro.com/2018/03/22/spring-boot-integration-test/"/>
    <id>http://www.deanwangpro.com/2018/03/22/spring-boot-integration-test/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-03-22T09:51:58.541Z</updated>
    
    <content type="html"><![CDATA[<p>如果希望很方便针对API进行测试，并且方便的集成到CI中验证每次的提交，那么spring boot自带的IT绝对是不二选择。</p><a id="more"></a><h3 id="迅速编写一个测试Case"><a href="#迅速编写一个测试Case" class="headerlink" title="迅速编写一个测试Case"></a>迅速编写一个测试Case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="meta">@ActiveProfiles</span>(&#123;Profiles.ENV_IT&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoIntegrationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"tested"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>SpringBootTest</code>定义了跑IT时的一些配置，上述代码是用了随机端口，当然也可以预定义端口，像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT, properties = &#123;&quot;server.port=9990&quot;&#125;)</span><br></pre></td></tr></table></figure><p><code>ActiveProfiles</code>强制使用了IT的Profile，从最佳实践上来说IT Profile所配置的数据库或者其他资源组件的地址，应该是与开发或者Staging环境隔离的。因为当一个IT跑完之后很多情况下我们需要清除测试数据。</p><p>你能够发现这样的Case可以使用<code>Autowired</code>注入任何想要的Service。这是因为spring将整个上下文都加载了起来，与实际运行的环境是一样的，包含了数据库，缓存等等组件。如果觉得测试时不需要全部的资源，那么在profile删除对应的配置就可以了。这就是一个完整的运行环境，唯一的区别是当用例跑完会自动shutdown。</p><h3 id="测试一个Rest-API"><a href="#测试一个Rest-API" class="headerlink" title="测试一个Rest API"></a>测试一个Rest API</h3><p>强烈推荐一个库，加入到gradle中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile &apos;io.rest-assured:rest-assured:3.0.3&apos;</span><br></pre></td></tr></table></figure><p>支持JsonPath，十分好用，具体文档戳<a href="https://github.com/rest-assured/rest-assured/wiki/GettingStarted" target="_blank" rel="noopener">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Sql(scripts = &quot;/testdata/users.sql&quot;)</span><br><span class="line">@Test</span><br><span class="line">public void test001Login() &#123;</span><br><span class="line">    String username = &quot;demo@demo.com&quot;;</span><br><span class="line">    String password = &quot;demo&quot;;</span><br><span class="line"></span><br><span class="line">    JwtAuthenticationRequest request = new JwtAuthenticationRequest(username, password);</span><br><span class="line"></span><br><span class="line">    Response response = given().contentType(ContentType.JSON).body(request)</span><br><span class="line">            .when().post(&quot;/auth/login&quot;).then()</span><br><span class="line">            .statusCode(HttpStatus.OK.value())</span><br><span class="line">            .extract()</span><br><span class="line">            .response();</span><br><span class="line"></span><br><span class="line">    assertThat(response.path(&quot;token&quot;), is(IsNull.notNullValue()));</span><br><span class="line">    assertThat(response.path(&quot;expiration&quot;), is(IsNull.notNullValue()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Sql</code>用于在测试前执行sql插入测试数据。注意<code>given().body()</code>中传入的是一个java对象<code>JwtAuthenticationRequest</code>，因为rest-assured会自动帮你用<code>jackson</code>将对象序列化成json字符串。当然也可以将转换好的json放到body，效果是一样的。</p><p>返回结果被一个Response接住，之后就可以用JsonPath获取其中数据进行验证。当然还有一种更直观的办法，可以通过<code>response.asString()</code>获取完整的response，再反序列化成java对象进行验证。</p><p>至此，最基本的IT就完成了。 在Jenkins增加一个step<code>gradle test</code>就可以实现每次提交代码都进行一次测试。</p><h3 id="一些复杂的情况"><a href="#一些复杂的情况" class="headerlink" title="一些复杂的情况"></a>一些复杂的情况</h3><h4 id="数据混杂"><a href="#数据混杂" class="headerlink" title="数据混杂"></a>数据混杂</h4><p>这是最容易发生，一个项目有很多dev，每个dev都会写自己的IT case，那么如果数据之间产生了影响怎么办。很容易理解，比如一个测试批量写的场景，最后验证方式是看写的数据量是不是10w行。那么另外一个dev写了其他的case恰好也新增了一条数据到这张表，结果变成了10w+1行，那么批量写的case就跑不过了。</p><p>为了杜绝这种情况，我们采用每次跑完一个测试Class就将数据清空。既然是基于类的操作，可以写一个基类解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">@ActiveProfiles(&#123;Profiles.ENV_IT&#125;)</span><br><span class="line">public abstract class BaseIntegrationTest &#123;</span><br><span class="line"></span><br><span class="line">    private static JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        jdbcTemplate = new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Value(&quot;$&#123;local.server.port&#125;&quot;)</span><br><span class="line">    protected int port;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setupEnv() &#123;</span><br><span class="line">        RestAssured.port = port;</span><br><span class="line">        RestAssured.basePath = &quot;/api&quot;;</span><br><span class="line">        RestAssured.baseURI = &quot;http://localhost&quot;;</span><br><span class="line">        RestAssured.config = RestAssured.config().httpClient(HttpClientConfig.httpClientConfig().httpMultipartMode(HttpMultipartMode.BROWSER_COMPATIBLE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void tearDownEnv() &#123;</span><br><span class="line">        given().contentType(ContentType.JSON)</span><br><span class="line">                .when().post(&quot;/auth/logout&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterClass</span><br><span class="line">    public static void cleanDB() throws SQLException &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;/testdata/CleanDB.sql&quot;);</span><br><span class="line">        Connection connection = jdbcTemplate.getDataSource().getConnection();</span><br><span class="line">        ScriptUtils.executeSqlScript(connection, resource);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@AfterClass</code>中使用了jdbcTemplate执行了一个CleanDB.sql，通过这种方式清除所有测试数据。</p><p><code>@Value(&quot;${local.server.port}&quot;)</code>也要提一下，因为端口是随机的，那么Rest-Assured不知道请求要发到losthost的哪个端口上，这里使用<code>@Value</code>获取当前的端口号并设置到<code>RestAssured.port</code>就解决了这个问题。</p><h4 id="共有数据怎么处理"><a href="#共有数据怎么处理" class="headerlink" title="共有数据怎么处理"></a>共有数据怎么处理</h4><p>跑一次完整的IT，可能需要经历数十个Class，数百个method，那么如果一些数据是所有case都需要的，只有在所有case都跑完才需要清除怎么办？换句话说，这种数据清理不是基于<strong>类</strong>的，而是基于一次<strong>运行</strong>。比如初始用户数据，城市库等等</p><p>我们耍了个小聪明，借助了<code>flyway</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123;DataSource.class&#125;)</span><br><span class="line">public class UpgradeAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public static final String FLYWAY = &quot;flyway&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name = FLYWAY)</span><br><span class="line">    @Profile(&#123;ENV_IT&#125;)</span><br><span class="line">    public UpgradeService cleanAndUpgradeService(DataSource dataSource) &#123;</span><br><span class="line">        UpgradeService upgradeService = new FlywayUpgradeService(dataSource);</span><br><span class="line">        try &#123;</span><br><span class="line">            upgradeService.cleanAndUpgrade();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            LOGGER.error(&quot;Flyway failed!&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        return upgradeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当Profile是IT的情况下，<code>flyway</code>会drop掉所有表并重新依次执行每次的upgrade脚本，由此创建完整的数据表，当然都是空的。在项目的test路径下，增加一个版本极大的sql，这样就可以让<code>flyway</code>在最后插入共用的测试数据，例如<code>src/test/resources/db/migration/V999.0.1__Insert_Users.sql</code> ，完美的解决各种数据问题。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用Spring boot内置的测试服务可以很快速的验证API，我现在都不用把服务启动再通过人工页面点击来测试自己的API，直接与前端同事沟通好Request的格式，写个Case就可以验证。</p><p>当然这种方式也有一个不足就是不方便对系统进行压力测试，之前在公司的API测试用例都是Jmeter写的，做性能测试的时候会方便很多。</p><p>仍在寻找合适的跑性能的工具，如有推荐欢迎留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果希望很方便针对API进行测试，并且方便的集成到CI中验证每次的提交，那么spring boot自带的IT绝对是不二选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="http://www.deanwangpro.com/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://www.deanwangpro.com/tags/spring-boot/"/>
    
      <category term="test" scheme="http://www.deanwangpro.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>坑系列之阿里SLB上使用Webscoket</title>
    <link href="http://www.deanwangpro.com/2018/03/10/Ali-SLB-for-Websocket/"/>
    <id>http://www.deanwangpro.com/2018/03/10/Ali-SLB-for-Websocket/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-03-12T01:51:14.193Z</updated>
    
    <content type="html"><![CDATA[<p>Websocket是HTML5之后的一个新事物，可以方便的实现客户端到服务端的长会话，特别适合用于客户端需要接收服务端推送的场景。例如在线客服聊天，提醒推送等等。改变了以往客户端只能通过轮询或者long poll来获取服务端状态的限制。</p><a id="more"></a><h3 id="和HTTP协议有什么关系"><a href="#和HTTP协议有什么关系" class="headerlink" title="和HTTP协议有什么关系"></a>和HTTP协议有什么关系</h3><p>首先我们来看一下Websocket协议和HTTP有什么关系呢？<br>本质上说，Websocket和HTTP就不是一个协议，层级不一样。但是为了兼容现有浏览器的握手规范，必须借助HTTP协议建立连接。</p><p>这是一个Websocket的握手请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET wss://server.example.com/ HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: https://server.example.com</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: fFFIlFcwULSAmQacRAbS2A==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>这里面有几个和一般HTTP Request不一样的地方，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: fFFIlFcwULSAmQacRAbS2A==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><p>这是告诉服务端这不是一个普通的请求，而是Websocket协议。Sec-WebSocket-Key 是一个Base64 encode的值，是浏览器随机生成的，用于让服务端知道这是一个全新的socket客户端。</p><p>服务端如果开启了Socket监听，那么就会返回这样的Response</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Date: Fri, 09 Mar 2018 16:24:45 GMT</span><br><span class="line">Connection: upgrade</span><br><span class="line">upgrade: websocket</span><br><span class="line">sec-websocket-accept: i/tCy92JmOXIoZwGi8ROh6CgUwk=</span><br></pre></td></tr></table></figure><p>表示接收了请求，并且即将切换到Websocket协议，所以code是101。Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。到这里HTTP协议的任务就已经完成，之后的通信都是基于Websocket协议了。</p><h3 id="怎么通过nginx转发Websocket的握手请求"><a href="#怎么通过nginx转发Websocket的握手请求" class="headerlink" title="怎么通过nginx转发Websocket的握手请求"></a>怎么通过nginx转发Websocket的握手请求</h3><p>本质上说握手请求就是一个特殊的HTTP Request，只是需要加一些上文提到的特殊内容，从<a href="https://www.nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">Nignx官方介绍</a>可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /wsapp/ &#123;</span><br><span class="line">    proxy_pass http://wsbackend;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">    proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是在Request header加了两个属性，并且强制升级到HTTP 1.1，原因是HTTP 1.0不支持keep alive。如果使用HTTP 1.0发握手请求，服务端返回101以后就会直接结束这次HTTP会话了。这一点也为之后的坑埋下了伏笔。</p><h3 id="坑从何来"><a href="#坑从何来" class="headerlink" title="坑从何来"></a>坑从何来</h3><p>自从上线了Websocket服务之后，就会经常发现socket无法建立，获得504的超时响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 504 Gateway Time-out</span><br><span class="line">Date: Fri, 09 Mar 2018 03:34:54 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 272</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>而且这一响应只有在经过SLB（负载均衡）时才有，如果直接请求到我们自己的nginx是没有问题的。但是基于对阿里的信任，还是觉得问题应该还是我们自己这儿。从code review到nginx配置，折腾了五六个小时。</p><p>最后只有自己搭建的nginx access log上寻找蛛丝马迹，一开始抓到一些响应都是499的返回，并且request_time时间都在60s上下。</p><blockquote><p>[09/Mar/2018:15:04:51 +0800] 100.97.89.10 - - - 10.0.21.11  to: 10.0.20.11:8011: GET /ws/?id=168451&amp;url=<a href="http://server.example.com/" target="_blank" rel="noopener">http://server.example.com/</a> HTTP/1.0 upstream_response_time - msec 1520579091.139 request_time <strong>60.000</strong> status 499 client - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</p></blockquote><p>就考虑是不是socket服务端建立连接后响应不及时，让SLB发现60s没有报文交互直接就切断请求了。</p><p>但是因为我们在前端是做了心跳的，即使服务端不响应，只要socket建立通过心跳肯定也会在60s内进行交互。不应该出现上面的场景。<br>之后我们把access log中socket建立成功的请求和不成功的请求分开放到一起对比，发现不成功的都是HTTP 1.0的协议。</p><blockquote><p>[09/Mar/2018:15:03:51 +0800] 100.97.88.238 - - - 10.0.20.11  to: 127.0.0.1:8011: GET /ws/?id=168451&amp;url=<a href="http://server.example.com" target="_blank" rel="noopener">http://server.example.com</a> <strong>HTTP/1.1</strong> upstream_response_time 11.069 msec 1520579031.198 request_time 11.|<br>069 status 101 client - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36                     |<br>[09/Mar/2018:15:04:32 +0800] 100.97.88.254 - - - 10.0.20.11  to: 127.0.0.1:8011: GET /ws/?id=168451&amp;url=<a href="http://server.example.com" target="_blank" rel="noopener">http://server.example.com</a> <strong>HTTP/1.0</strong> upstream_response_time - msec 1520579072.716 request_time 36.755 s|<br>tatus 499 client - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36</p></blockquote><p>就好像这两个请求，同一个页面发出的，但是一个成功一个失败。失败的正好就是HTTP/1.0，为什么会有两个版本的协议呢，<br>为了证据更加“确凿”，我们对请求进行了抓包分析，并将Sec-WebSocket-Key打印到Nginx的access log中方便trace同一个请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET http://server.example.com/ws/ HTTP/1.1</span><br><span class="line">Host: app.linkflowtech.com</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http://server.example.com</span><br><span class="line">Sec-WebSocket-Key: 8+qDYeKJGFTWKB2ov4p5TA==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure><blockquote><p>[09/Mar/2018:17:07:07 +0800] 100.97.88.252 - - - 10.0.21.11  to: 10.0.20.11:8011: GET /ws/ HTTP/1.0 upstream_response_time - msec 1520586427.537 request_time 59.999 status 499 client - Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36 <strong>8+qDYeKJGFTWKB2ov4p5TA==</strong><br>2018-03-09 17:12:04</p></blockquote><p>可以看到都是 <strong>8+qDYeKJGFTWKB2ov4p5TA==</strong> 的请求，但是在经过SLB进入nginx时候协议降级到了1.0.这叫一个酸爽，赶紧给阿里云开了工单，经过大概3~4个小时的交流。最终获得一个链接，里面有这样的描述</p><blockquote><p>如何在阿里云负载均衡上启用WS/WSS支持？<br>无需配置，当选用HTTP监听时，默认支持无加密版本WebSocket协议（WS协议）；当选择HTTPS监听时，默认支持加密版本的WebSocket协议（WSS协议）。<br>注意：需要将实例升级为<strong>性能保障型实例</strong>。详细参见如何使用负载均衡性能保障型实例。</p></blockquote><p>这个大坑就在”注意”那一段，我们的SLB是性能共享型而不是性能保障型。看来也不是阿里云的问题，是我们的SLB档次不够高啊。知道原因后，立刻付费升级了保障型。实测一下所有问题都解决了。</p><p>虽然问题解决了，但是其实很难理解厂商的逻辑，为什么性能共享型中某些SLB节点就会降级HTTP协议版本呢，要知道1.0版本已经是一个相当落后的版本了。</p><p>在此记录一下心路历程，为了让其他使用阿里云的同学不要重蹈覆辙。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Websocket是HTML5之后的一个新事物，可以方便的实现客户端到服务端的长会话，特别适合用于客户端需要接收服务端推送的场景。例如在线客服聊天，提醒推送等等。改变了以往客户端只能通过轮询或者long poll来获取服务端状态的限制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://www.deanwangpro.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>压测工具wrk和Artillery的比较</title>
    <link href="http://www.deanwangpro.com/2017/12/09/wrk-and-artillery/"/>
    <id>http://www.deanwangpro.com/2017/12/09/wrk-and-artillery/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2017-12-22T06:06:05.393Z</updated>
    
    <content type="html"><![CDATA[<p>这两天抽空使用了一下两款压测工具</p><ul><li>wrk</li><li>Artillery</li></ul><p>并且通过两款工具对产品的两个环境进行了测试<br><a id="more"></a></p><h3 id="工具比较"><a href="#工具比较" class="headerlink" title="工具比较"></a>工具比较</h3><h4 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h4><p>wrk自身性能就非常惊人，使用epoll这种多路复用技术，所以可以用少量的线程来跟被测服务创建大量连接，进行压测，同时不占用过多的CPU和内存。</p><p>命令非常简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t8 -c200 -d30s --latency  <span class="string">"http://www.baidu.com"</span></span><br></pre></td></tr></table></figure><p>这样就可以进行最简单的压测。但是真实使用起来肯定会有复杂的场景，比如先要登录取到token再进行下一步。好在wrk支持lua脚本，提供了几个阶段的hook来让用户自定义逻辑，具体可以看github上的官方提供的script sample。</p><p>我这里举一个获取token的例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- @Author: wangding</span></span><br><span class="line"><span class="comment">-- @Date:   2017-12-06 15:13:19</span></span><br><span class="line"><span class="comment">-- @Last Modified by:   wangding</span></span><br><span class="line"><span class="comment">-- @Last Modified time: 2017-12-06 23:57:49</span></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span></span><br><span class="line"><span class="keyword">local</span> cjson2 = cjson.new()</span><br><span class="line"><span class="keyword">local</span> cjson_safe = <span class="built_in">require</span> <span class="string">"cjson.safe"</span></span><br><span class="line"></span><br><span class="line">token = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">path</span>  = <span class="string">"/api/auth/login"</span></span><br><span class="line">method = <span class="string">"POST"</span></span><br><span class="line"></span><br><span class="line">wrk.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line"></span><br><span class="line">request = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">return</span> wrk.<span class="built_in">format</span>(method, <span class="built_in">path</span>, <span class="literal">nil</span>, <span class="string">'&#123;"username":"demo@demo.com","password":"demo"&#125;'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">response = <span class="function"><span class="keyword">function</span><span class="params">(status, headers, body)</span></span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> token <span class="keyword">and</span> <span class="built_in">status</span> == <span class="number">200</span> <span class="keyword">then</span></span><br><span class="line">      value = cjson.decode(body)</span><br><span class="line">      token = value[<span class="string">"token"</span>]</span><br><span class="line">      method = <span class="string">"GET"</span></span><br><span class="line">      <span class="built_in">path</span>  = <span class="string">"/api/contact?size=20&amp;page=0"</span></span><br><span class="line">      wrk.headers[<span class="string">"Authorization"</span>] = token</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>request</code> 和 <code>response</code> 分别是两个hook，每次请求都会调用，那么这里request的逻辑就是一开始就使用<code>POST</code>请求<code>/api/auth/login</code>并且带有body，请求完成进入response，第一次token肯定是nil，所以把repose的token解析出来付给全局变量<code>token</code>，之后改写全局变量为<code>GET</code>请求地址<code>/api/contact</code>并且设置了header包含<code>Authorization</code>。</p><p>这样实际是变通的实现了一个简单scenario的测试，那么问题来了，如果场景更复杂怎么办？写肯定是可以写的，但是并不直观，所以wrk不太适合一个包含有序场景的压力测试。</p><p>再来看一下wrk的report，这一点是我最喜欢的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wrk -t8 -c200 -d30s -H <span class="string">"Authorization: token"</span> --latency <span class="string">"http://10.0.20.2:8080/api/contact?size=20&amp;page=0"</span></span><br><span class="line">Running 30s <span class="built_in">test</span> @ http://10.0.20.2:8080/api/contact?size=20&amp;page=0</span><br><span class="line">  8 threads and 200 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   769.49ms  324.43ms   1.99s    72.08%</span><br><span class="line">    Req/Sec    33.37     21.58   131.00     62.31%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  728.97ms</span><br><span class="line">     75%  958.69ms</span><br><span class="line">     90%    1.21s</span><br><span class="line">     99%    1.74s</span><br><span class="line">  7606 requests <span class="keyword">in</span> 30.03s, 176.69MB <span class="built_in">read</span></span><br><span class="line">  Socket errors: connect 0, <span class="built_in">read</span> 0, write 0, timeout 38</span><br><span class="line">Requests/sec:    253.31</span><br><span class="line">Transfer/sec:      5.88MB</span><br></pre></td></tr></table></figure><p>开启8线程，每个线程200个连接，持续30s的调用，可以看到报告中直接给出了最关键的指标QPS，这里的值是253.31。平均响应时间是33.37ms。简单直接，非常易懂。</p><p>但是这里面有个坑就是cjson这个lua module的使用，不可以使用lua5.2，必须使用lua5.1而且需要特定的wrk和cjson。我直接使用docker来封装这个运行环境，坏处是docker使用host模式本身性能可能就有影响。</p><h4 id="Artillery"><a href="#Artillery" class="headerlink" title="Artillery"></a>Artillery</h4><p>一开始看到Artillery主要是因为它支持带场景的测试，也就是带有步骤，看一眼获取token再进行下一步的脚本。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">  target:</span> <span class="string">"http://10.0.20.2:8080"</span></span><br><span class="line"><span class="attr">  phases:</span></span><br><span class="line"><span class="attr">    - duration:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">      arrivalRate:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">scenarios:</span></span><br><span class="line"><span class="attr">  - flow:</span></span><br><span class="line"><span class="attr">    - post:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">"/api/auth/login"</span></span><br><span class="line"><span class="attr">        json:</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">"demo@demo.com"</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">"demo"</span></span><br><span class="line"><span class="attr">        capture:</span></span><br><span class="line"><span class="attr">          json:</span> <span class="string">"$.token"</span></span><br><span class="line"><span class="attr">          as:</span> <span class="string">"token"</span></span><br><span class="line"><span class="attr">    - log:</span> <span class="string">"Login token: <span class="template-variable">&#123;&#123; token &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">    - get:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="string">"/api/contact?size=20&amp;page=0"</span></span><br><span class="line"><span class="attr">        headers:</span></span><br><span class="line"><span class="attr">          Authorization:</span> <span class="string">"<span class="template-variable">&#123;&#123; token &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure><p><code>flow</code>就是表示步骤，<code>duration</code>表示持续30s，跟wrk不同的是没有thread的概念，Artillery是nodejs写的，<code>arrivalRate</code>表示每秒模拟100个请求，所以两个参数乘起来就是3000个请求。看一下报告什么样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">All virtual users finished</span><br><span class="line">Summary report @ 12:45:41(+0800) 2017-12-08</span><br><span class="line">  Scenarios launched:  3000</span><br><span class="line">  Scenarios completed: 3000</span><br><span class="line">  Requests completed:  3000</span><br><span class="line">  RPS sent: 98.33</span><br><span class="line">  Request latency:</span><br><span class="line">    min: 15.7</span><br><span class="line">    max: 179.1</span><br><span class="line">    median: 19</span><br><span class="line">    p95: 25.8</span><br><span class="line">    p99: 37.5</span><br><span class="line">  Scenario duration:</span><br><span class="line">    min: 16.4</span><br><span class="line">    max: 191.4</span><br><span class="line">    median: 19.8</span><br><span class="line">    p95: 27</span><br><span class="line">    p99: 44.6</span><br><span class="line">  Scenario counts:</span><br><span class="line">    0: 3000 (100%)</span><br><span class="line">  Codes:</span><br><span class="line">    200: 3000</span><br></pre></td></tr></table></figure><p>这里的<code>RPS sent</code>是指前10s平均发送请求数，所以这个和我们常说的QPS还是不一样的。如果想提高request的总数就要增加<code>arrivalRate</code>，比如上文wrk一共发了7606请求，那么这里<code>arrivalRate</code>提高到200一共可以在30s发6000次，但是改完就悲剧了，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: High CPU usage warning.</span><br><span class="line">See https://artillery.io/docs/faq/<span class="comment">#high-cpu-warnings for details.</span></span><br></pre></td></tr></table></figure><p>Artillery一直在不断的告警，说明这个工具自身的局限性导致想要并发发送大量请求的时候，自己就很占CPU。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>wrk小巧而且性能非常好，报告直观。但是对于带多个步骤的压测场景无力。<br>Artillery太耗资源，而且报告不直观。<strong>不建议采用</strong>。<br>除此之外唯一带场景的测试工具就是Jmeter了，但是Jmeter本身使用JVM是否可以短时间模拟大量并发，还是需要测试，建议与wrk做对比实验。</p><h3 id="附录：简单的性能调优"><a href="#附录：简单的性能调优" class="headerlink" title="附录：简单的性能调优"></a>附录：简单的性能调优</h3><p>在用wrk测试GET请求的时候，发现无论如何提高连接数，QPS都是在250左右，此时CPU和内存都没有占满。怀疑是有其他瓶颈。最后发现Spring Boot内嵌的tomcat线程无法突破200，所以看了一下文档，发现默认最大线程数就是200，对<code>application.yml</code>进行了调整（同时调整了多个服务，包括gateway）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  tomcat:</span></span><br><span class="line"><span class="attr">    max-threads:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">    max-connections:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>调整之后开启8线程，每个100个连接测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Running 30s <span class="built_in">test</span> @ http://10.0.10.4:8769/api/contact?size=20&amp;page=0</span><br><span class="line">  8 threads and 100 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   235.56ms  267.57ms   1.98s    91.07%</span><br><span class="line">    Req/Sec    72.12     30.19   190.00     68.17%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%  166.46ms</span><br><span class="line">     75%  281.10ms</span><br><span class="line">     90%  472.03ms</span><br><span class="line">     99%    1.45s</span><br><span class="line">  15714 requests <span class="keyword">in</span> 30.03s, 4.77MB <span class="built_in">read</span></span><br><span class="line">Requests/sec:    523.29</span><br><span class="line">Transfer/sec:    162.56KB</span><br></pre></td></tr></table></figure><p>可以看到QPS达到了500以上直接翻倍了，再尝试提高连接数发现瓶颈就在内存了。</p><p>此外之前用公网做了一次压测，QPS只有10左右，看了一下阿里云的监控原来是出口带宽造成的，只有1MB的出口带宽，连接数调多大也没用。</p><p>未来还需要进行场景的细化，再决定是否使用不同的工具进行测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天抽空使用了一下两款压测工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wrk&lt;/li&gt;
&lt;li&gt;Artillery&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且通过两款工具对产品的两个环境进行了测试&lt;br&gt;
    
    </summary>
    
    
      <category term="Test" scheme="http://www.deanwangpro.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>List Merge的小算法</title>
    <link href="http://www.deanwangpro.com/2017/10/04/list-merge/"/>
    <id>http://www.deanwangpro.com/2017/10/04/list-merge/</id>
    <published>2017-10-03T16:00:00.000Z</published>
    <updated>2018-05-16T06:46:07.848Z</updated>
    
    <content type="html"><![CDATA[<p>今天说一个算法小甜点，因为对于算法知之甚少，所以完全是自己揣摩出来的一则，写出来只是个记录，如有更学术派的解法欢迎评论。<br><a id="more"></a></p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>我们系统有一个去重的需求，但是查重的维度是多方面的，举个例子，若干个用户用了用一个手机号，那么我们就认为他们是同一个人，用手机号码这个条件可以查出一组这样的人。同理用Email也是。</p><p>但是存在一个问题就是用手机号查出了5组人，用Email查出了3组人，最后我们可以认为重复的人是8吗？其实是不行的，因为有可能某几个人的手机号和Email都是一样的，那么在两次查询后都会将这些人纳入到统计中。所以最后统计出的结果应该是&lt;=各次查询结果之和的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>首先是数据结构，每次查询出来的结构是一个List，那么List里面其实又是一组重复的人。</p><p>为了方便理解，我们可以定义一个最小化结构为Group，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; duplications = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的duplicates代表原始记录ID列表，举例说就是ID=13和ID=15的两条记录都是用的同一个手机号，那么duplications就是{13,15}。</p><p>每通过一个条件查询可以得到一个List<group>的返回，很好理解，这个List的size就是说明有多少人用了相同的手机号。那么用Email查询的话结果就是代表多少人用了相同的Email。</group></p><p>假设ID=13的这条记录，它已经在用手机号查询的结果中被GroupA收录，如果它又在Email查询的结果中被GroupF收录的话，说明了什么问题？说明其实GroupA和GroupF应该取个合集，他们都是代表了同一个人。有点类似消消乐的意思。我们最后其实不管是通过什么条件查出来的，只要是一个Group的集合就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个篮子</span></span><br><span class="line">List&lt;Group&gt; duplicateBucket = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="comment">// 若干条件) &#123;</span></span><br><span class="line">    List&lt;Group&gt; duplicates = queryProvider.queryDuplications();</span><br><span class="line">    duplicateBucket.addAll(duplicates);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对这个篮子做一次去重</span></span><br><span class="line">DeduplicationUtils.intersection(duplicateBucket);</span><br></pre></td></tr></table></figure><p>再看这个去重的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intersection</span><span class="params">(List&lt;Grouop&gt; duplicates)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = duplicates.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = duplicates.size() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            Set&lt;Long&gt; setA = duplicates.get(i).toSet();</span><br><span class="line">            Set&lt;Long&gt; setB = duplicates.get(j).toSet();</span><br><span class="line">            Set intersection = Sets.intersection(setA, setB);</span><br><span class="line">            <span class="keyword">if</span> (intersection.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 找出差集做合并</span></span><br><span class="line">                List&lt;Long&gt; differences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Long id : duplicates.get(j).getDuplications()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (intersection.contains(id)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    differences.add(id);</span><br><span class="line">                &#125;</span><br><span class="line">                duplicates.get(i).addAllDuplications(differences);</span><br><span class="line">                duplicates.remove(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是关键，实际上就是双层遍历做对比，发现重复条目就做消消乐，让后者融合进前者的集合中去。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这样就基本解决了去重的问题，但是效率一般，毕竟有双重循环在。如有更好的办法欢迎留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说一个算法小甜点，因为对于算法知之甚少，所以完全是自己揣摩出来的一则，写出来只是个记录，如有更学术派的解法欢迎评论。&lt;br&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.deanwangpro.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Collection" scheme="http://www.deanwangpro.com/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Activiti系列一之delegate拦截器</title>
    <link href="http://www.deanwangpro.com/2017/09/11/activiti-delegate-interceptor/"/>
    <id>http://www.deanwangpro.com/2017/09/11/activiti-delegate-interceptor/</id>
    <published>2017-09-10T16:00:00.000Z</published>
    <updated>2017-10-04T07:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司内部的工作流引擎用的是Activiti5, 所以这半年一直在研究这个开源项目，打算针对这个项目做一个系列，说一说使用心得。今天就先做系列一，先说使用场景。</p><a id="more"></a><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Activiti可以很好的与Spring结合，只需要使用<code>SpringProcessEngineConfiguration</code>配置就可以利用Spring管理Bean，所以在BPMN的标准中Activiti的扩展属性都是可以使用Spring Bean的。</p><p>例如Service Task，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">"N0db890f126c2"</span> <span class="attr">name</span>=<span class="string">"Service Task"</span> <span class="attr">activiti:delegateExpression</span>=<span class="string">"#&#123;serviceTaskDelegate&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">serviceTask</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>activiti:delegateExpression</code>中使用的就是一个Spring Bean，这个Bean实际上是一个JavaDelegate的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTaskDelegate</span> <span class="keyword">implements</span> <span class="title">JavaDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ContactGroupService contactGroupService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeDelegate</span><span class="params">(DelegateExecution execution, ContactDTO contactDTO)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"start execute action..."</span>);             </span><br><span class="line">        LOGGER.info(<span class="string">"end execute add group action..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Bean和其他Spring Bean没有区别，可以注入其他Service，自己也会在Spring上下文中加载。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>接下来深入的一步讨论就是如何处理复杂的事务，一个工作流中包含若干个上述的Service Task，那么究竟是一个Task失败，整个流程就回滚还是一个失败之后，流程停止在失败的地方然后重试呢？</p><p>这些都需要根据具体的业务场景来处理，Activiti默认采取第一种办法直接全部回滚。在我们的场景中做了一些改动，当出现重试可解决的异常时全部回滚，整个流程等待若干秒后再次重试，当出现重试也无法解决的异常时，例如超出API调用次数之类的，流程直接失败并记录状态。</p><p>另外在单个ServiceTask的运行过程中，我们采取了新开一个事务的办法，避免与Activiti自身事务互相影响，另一方面也可以复用我们系统多租户的拦截器来处理复杂的数据库查询（非框架程序员不用处理租户相关的代码）。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>仔细阅读Activiti源码，发现在配置类中有一个<code>processEngineConfiguration.setDelegateInterceptor</code>方法，这个拦截器是在具体的Delegate启动之前调用的，所以就给了我们一个时机切入到业务逻辑之前。</p><p>不含糊，直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDelegateInterceptor</span> <span class="keyword">implements</span> <span class="title">DelegateInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ActivitiWorkflowManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TenantResolver tenantResolver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomDelegateInterceptor</span><span class="params">(TenantResolver tenantResolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tenantResolver = tenantResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInvocation</span><span class="params">(DelegateInvocation invocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> JavaDelegate) &#123;</span><br><span class="line">            Field executionField = ReflectionUtils.findField(JavaDelegateInvocation.class, <span class="string">"execution"</span>, DelegateExecution.class);</span><br><span class="line">            ReflectionUtils.makeAccessible(executionField);</span><br><span class="line">            DelegateExecution execution = (DelegateExecution) ReflectionUtils.getField(executionField, invocation);</span><br><span class="line">            <span class="comment">// 异步任务需要设置TenantId</span></span><br><span class="line">            LOGGER.info(<span class="string">"Executing activiti service task tenantId [&#123;&#125;]"</span>, execution.getTenantId());</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(execution.getTenantId())) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"do not have tenantId, skipped"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tenantResolver.setCurrentTenant(Long.valueOf(execution.getTenantId()));</span><br><span class="line">                String traceId = execution.getProcessBusinessKey() + <span class="string">":"</span> + execution.getProcessInstanceId();</span><br><span class="line">                LogTraceUtils.beginTrace(traceId);</span><br><span class="line">                invocation.proceed();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                tenantResolver.clear();</span><br><span class="line">                LogTraceUtils.endTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个Service Task执行前，都会获取当前这个流程的租户ID并且写入到一个专门管理租户ID的ThreadLocal中。并且切入了一段日志逻辑方便排错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有些时候就是这样一个不经意的小函数就可以优雅的实现一个类似AOP的拦截。往往这种小函数在文档中是只字不提的，可见对于开源项目源码阅读的重要性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司内部的工作流引擎用的是Activiti5, 所以这半年一直在研究这个开源项目，打算针对这个项目做一个系列，说一说使用心得。今天就先做系列一，先说使用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="BPMN" scheme="http://www.deanwangpro.com/tags/BPMN/"/>
    
      <category term="Activiti" scheme="http://www.deanwangpro.com/tags/Activiti/"/>
    
  </entry>
  
  <entry>
    <title>短链接的简单实现</title>
    <link href="http://www.deanwangpro.com/2017/08/20/dwz/"/>
    <id>http://www.deanwangpro.com/2017/08/20/dwz/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-09-11T15:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没更新了，加入了创业公司，从无到有的构建一套产品，从一开始的码框架到现在思考如何优化产品架构，适应更多的弹性需求和更大的数据量。时间真的是不够用，几乎快半年没有更新博客。近期产品慢慢走上正轨，又有小伙伴加入，所以抽出点时间总结一下这小半年内遇到的坑和走过的路。<br><a id="more"></a></p><p>说一说最近做的一个短链服务，短链服务其实很简单，其实就是一张表或者说是一个map：<br>+——-+———————–+<br>|  短链  |         长链           |<br>+——-+———————–+<br>| 7Y65s | <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> |<br>+——-+———————–+</p><p>就是这样一个结构，当用户访问 your-domain/7Y65s, 去表里查询一下对应的长链，301到该链接就可以了。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>基本的思路确定后，我们一点一点来优化。</p><p>首先分析大量查询肯定会出现在通过短链找长链这段逻辑中，如果用数据库肯定影响效率，缓存势在必行，而且一旦短链生成基本是不会变的，所以也不存在失效问题（这里可能会有个批量Archive的处理）。在我的项目中，我选择了redis作为缓存，反正是key-value的其他缓存组件肯定也能做。选用redis的原因是还可以用INCR来统计访问量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForHash().put(&quot;short-urls:&quot; + slug, &quot;long_url&quot;, url);</span><br><span class="line">redisTemplate.opsForHash().increment(&quot;short-urls:&quot; + slug, VISITS_FIELD, 1L);</span><br></pre></td></tr></table></figure><p>查询这一侧做完，到了生成短链这一块，这里实际上是刚刚说的那张表的create操作。这里有个基本逻辑是：当一个长链还没有短链的时候，我们生成它并返回，如果已经存在，直接获取返回。</p><p>生成的算法直接贴代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package io.naza.urlshortener.generator;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line">public class UrlShortHelper &#123;</span><br><span class="line"></span><br><span class="line">    private final static int LENGTH = 6;</span><br><span class="line"></span><br><span class="line">    private static char[] DIGITS = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;.toCharArray();</span><br><span class="line"></span><br><span class="line">    public static String[] shorten(String url) &#123;</span><br><span class="line">        String key = &quot;SECRET&quot;; // 自定义生成MD5加密字符串前的混合KEY</span><br><span class="line">        String hex = DigestUtils.md5Hex(key + url);</span><br><span class="line">        int hexLen = hex.length();</span><br><span class="line">        int subHexLen = hexLen / 8;</span><br><span class="line">        String[] shortStr = new String[subHexLen];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; subHexLen; i++) &#123;</span><br><span class="line">            StringBuilder outChars = new StringBuilder();</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            String subHex = hex.substring(i * 8, j * 8);</span><br><span class="line">            long idx = Long.valueOf(&quot;3FFFFFFF&quot;, 16) &amp; Long.valueOf(subHex, 16);</span><br><span class="line">            for (int k = 0; k &lt; LENGTH; k++) &#123;</span><br><span class="line">                int index = (int) (Long.valueOf(&quot;0000003D&quot;, 16) &amp; idx);</span><br><span class="line">                outChars.append(DIGITS[index]);</span><br><span class="line">                idx = idx &gt;&gt; 5;</span><br><span class="line">            &#125;</span><br><span class="line">            shortStr[i] = outChars.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        return shortStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中按照长链生成一个固定长度为6位的短链接，只要长链是一样的，那么每次生成的短链也一样。</p><p>考虑到每次生成短链前要查询一下长链是不是存在，继续加一个小缓存，这次反过来，长链作key，短链做value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForHash().put(&quot;short-urls&quot;, url, slug);</span><br></pre></td></tr></table></figure><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>用比较简单的方式完成一个短链接服务，在做短链跳转的过程中可以分析用户的各类行为，比如操作系统，浏览器版本，地域等等。最后说两点要注意的：</p><ol><li>redis毕竟是作为缓存使用的，建议数据还是要落一次在DB，比如在生成短链时，写入到DB一份。这样当redis挂了，还可以从DB中全量恢复。</li><li>对于长时间没有PV的短链，比如超过1年没有PV，需要做批量清理，一般一个月一次就可以了。 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没更新了，加入了创业公司，从无到有的构建一套产品，从一开始的码框架到现在思考如何优化产品架构，适应更多的弹性需求和更大的数据量。时间真的是不够用，几乎快半年没有更新博客。近期产品慢慢走上正轨，又有小伙伴加入，所以抽出点时间总结一下这小半年内遇到的坑和走过的路。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.deanwangpro.com/tags/Java/"/>
    
      <category term="Redis" scheme="http://www.deanwangpro.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot监控初探</title>
    <link href="http://www.deanwangpro.com/2017/03/22/spring-boot-monitor/"/>
    <id>http://www.deanwangpro.com/2017/03/22/spring-boot-monitor/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-26T14:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近对devOps这个话题有点兴趣，所以研究了一下monitor相关的开源项目，翻到medium上的<a href="https://medium.com/@brunosimioni/near-real-time-monitoring-charts-with-spring-boot-actuator-jolokia-and-grafana-1ce267c50bcc#.il5xmlnv7" target="_blank" rel="noopener">一篇文章</a>,而且实际项目中也曾看到devOps组的同事搭过类似的监控，就想过把瘾，了解一下监控可视化。<br><a id="more"></a></p><h3 id="被监控服务配置"><a href="#被监控服务配置" class="headerlink" title="被监控服务配置"></a>被监控服务配置</h3><p>本地正好有spring-boot的项目，并且也依赖了<code>jolokia</code>（主要就是为了把JMX的mbean通过HTTP暴露出去）<br>项目配置也少不了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    jmx:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    jolokia:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">    security:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>访问一下URL看看是不是ok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/jolokia/read/org.springframework.boot:name=metricsEndpoint,type=Endpoint/Data</span><br></pre></td></tr></table></figure><h3 id="搭建监控系统"><a href="#搭建监控系统" class="headerlink" title="搭建监控系统"></a>搭建监控系统</h3><p>如果能看到数据，说明server端配置没问题了，下面我们怎么搭建Telegraf + InfluxDB + Grafana呢，这个三个组件是这么配合的，Telegraf实际就是收集信息的，比如每隔10s访问一次上面那个URL得到metrics，收集到的数据存到InfluxDB，然后Grafana做数据可视化。<br>但是如果纯手动安装实在太麻烦，求助万能的github，找到一个非常棒的项目(<a href="https://github.com/samuelebistoletti/docker-statsd-influxdb-grafana)" target="_blank" rel="noopener">https://github.com/samuelebistoletti/docker-statsd-influxdb-grafana)</a>, 直接fork然后修改一些配置就可以为自己的项目服务了。如果你不了解相关配置可以先直接run起来，然后通过ssh进去一探究竟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@localhost -p 22022</span><br></pre></td></tr></table></figure><p>配置方面，主要是要修改Telegraf的，因为它是对接不同项目的，你需要收集什么样的信息，比如cpu，disk，net等等都要在Telegraf里配。简单起见，我只设置了三个输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># /etc/telegraf/telegraf.conf</span><br><span class="line">[[inputs.jolokia]]</span><br><span class="line">  context = &quot;/jolokia&quot;</span><br><span class="line"></span><br><span class="line">[[inputs.jolokia.servers]]</span><br><span class="line">    name = &quot;springbootapp&quot;</span><br><span class="line">    host = &quot;&#123;app ip address&#125;&quot;</span><br><span class="line">    port = &quot;8080&quot;</span><br><span class="line"></span><br><span class="line">[[inputs.jolokia.metrics]]</span><br><span class="line">    name = &quot;metrics&quot;</span><br><span class="line">    mbean  = &quot;org.springframework.boot:name=metricsEndpoint,type=Endpoint&quot;</span><br><span class="line">    attribute = &quot;Data&quot;</span><br><span class="line">    </span><br><span class="line">[[inputs.jolokia.metrics]]</span><br><span class="line">    name = &quot;tomcat_max_threads&quot;</span><br><span class="line">    mbean  = &quot;Tomcat:name=\&quot;http-nio-8080\&quot;,type=ThreadPool&quot;</span><br><span class="line">    attribute = &quot;maxThreads&quot;</span><br><span class="line"></span><br><span class="line">[[inputs.jolokia.metrics]]</span><br><span class="line">    name = &quot;tomcat_current_threads_busy&quot;</span><br><span class="line">    mbean  = &quot;Tomcat:name=\&quot;http-nio-8080\&quot;,type=ThreadPool&quot;</span><br><span class="line">    attribute = &quot;currentThreadsBusy&quot;</span><br></pre></td></tr></table></figure><p>其实就是spring-boot标准的metrics以及tomcat的Threads。<br>完成之后重启服务<code>/etc/init.d/telegraf restart</code></p><h3 id="查看监控数据"><a href="#查看监控数据" class="headerlink" title="查看监控数据"></a>查看监控数据</h3><p>我们访问InfluxDB看看有数据了没有<code>http://localhost:3004/</code>，切换数据库到Telegraf。输入以下命令试试吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW MEASUREMENTS</span><br><span class="line">SELECT * FROM jolokia</span><br><span class="line">SELECT * FROM cpu</span><br><span class="line">SELECT * FROM mem</span><br><span class="line">SELECT * FROM diskio</span><br></pre></td></tr></table></figure><p>比如输入<code>SELECT * FROM jolokia</code>就能看到spring-boot暴露了哪些数据，从time列也可以看出Telegraf是每隔10s收集一次，太频繁了对server也是压力。<br><img src="/images/Jolokia.png" alt="Jolokia"></p><p>上面基本涵盖了cpu，内存和存储的一些metrics。<br>其实也可以配置网络相关的，感兴趣的可以看官方的telegraf.conf，里面有配置[[inputs.net]]的例子。</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>数据有了，下一步就是可视化。<br>按照Github上面说的进入<code>http://localhost:3003/</code>，</p><ol><li>Using the wizard click on <code>Add data source</code></li><li>Choose a <code>name</code> for the source and flag it as <code>Default</code></li><li>Choose <code>InfluxDB</code> as <code>type</code></li><li>Choose <code>direct</code> as <code>access</code></li><li>Fill remaining fields as follows and click on <code>Add</code> without altering other fields</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Url: http://localhost:8086</span><br><span class="line">Database:telegraf</span><br><span class="line">User: telegraf</span><br><span class="line">Password:telegraf</span><br></pre></td></tr></table></figure><p>添加好InfluxDB后，新建一个Dashboard，然后快速的ADD几个Graph来。<br>为了演示，我添加了三个，分别使用下面三组查询语句来渲染出三张图表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT MEAN(usage_system) + MEAN(usage_user) AS cpu_total FROM cpu WHERE $timeFilter GROUP BY time($interval)</span><br><span class="line"></span><br><span class="line">SELECT mean(&quot;total&quot;) as &quot;total&quot; FROM &quot;mem&quot; WHERE $timeFilter GROUP BY time($interval) fill(null)</span><br><span class="line">SELECT mean(&quot;used&quot;) as &quot;used&quot; FROM &quot;mem&quot; WHERE $timeFilter GROUP BY time($interval) fill(null)</span><br><span class="line"></span><br><span class="line">SELECT mean(&quot;metrics_heap.used&quot;) as &quot;heap_usage&quot; FROM &quot;jolokia&quot; WHERE $timeFilter GROUP BY time($interval) fill(null)</span><br></pre></td></tr></table></figure><p>第一张是CPU占用率；第二张是内存占用情况，绿线是Total，黄线是Used；第三张是jolokia提供的jvm heap的使用，可以到看到GC的情况。</p><p><img src="/images/Grafana.png" alt="Grafana"></p><p>刚才还配置了Tomcat的收集，想看Tomcat的Thread情况也是妥妥的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT mean(&quot;tomcat_max_threads&quot;) FROM &quot;jolokia&quot; WHERE $timeFilter GROUP BY time($interval) fill(null)</span><br><span class="line">SELECT mean(&quot;tomcat_current_threads_busy&quot;) FROM &quot;jolokia&quot; WHERE $timeFilter GROUP BY time($interval) fill(null)</span><br></pre></td></tr></table></figure><p><img src="/images/tomcat.png" alt="tomcat"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>可以看到搭建这样一套环境其实很快，原理也并不复杂，监控数据可视化的难点在于</p><ul><li>哪些metrics需要监控</li><li>哪些metrics需要配合起来可以判断问题，比如diskio+net是不是可以判断系统整体IO的瓶颈。</li></ul><p>这都是需要多年的经验总结才能获得的，我还是菜鸟一枚，再接再厉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对devOps这个话题有点兴趣，所以研究了一下monitor相关的开源项目，翻到medium上的&lt;a href=&quot;https://medium.com/@brunosimioni/near-real-time-monitoring-charts-with-spring-boot-actuator-jolokia-and-grafana-1ce267c50bcc#.il5xmlnv7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;,而且实际项目中也曾看到devOps组的同事搭过类似的监控，就想过把瘾，了解一下监控可视化。&lt;br&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.deanwangpro.com/tags/Spring/"/>
    
      <category term="DevOps" scheme="http://www.deanwangpro.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>说一说微信第三方平台的初步集成</title>
    <link href="http://www.deanwangpro.com/2017/03/20/wechat-open-platform/"/>
    <id>http://www.deanwangpro.com/2017/03/20/wechat-open-platform/</id>
    <published>2017-03-19T16:00:00.000Z</published>
    <updated>2017-03-22T03:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信火了这么久，这两周第一次从一个开发者的角度来研究微信的生态系统而不是应用本身。现在做国内的项目或者产品难免都需要集成微信，其实现在微信背后的支撑平台已经是非常繁杂的了：</p><ul><li>公众平台（订阅号、服务号、企业号、小程序）</li><li>开放平台（网页应用、移动应用、公众号第三方平台开发）</li><li>商户平台 （支付）</li><li>服务商平台（代支付）</li></ul><a id="more"></a><p>是不是感觉有点懵，这么多平台如何选择，还是需要根据自己系统的业务来看。我今天说的是开放平台的初步集成。</p><p>采用倒序的方式我们一步步来说：</p><ol><li><p>开放平台需要代公众号实现功能，就必须拿到公众号的<code>accessToken</code>，然后再去使用公众平台接口。那么获取<code>accessToken</code>的过程实际就是公众平台授权给你这个第三方开放平台的过程。相当于他给你了一把打开他家门的钥匙。详见<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1453779503&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">官方文档</a>第5步.</p></li><li><p>获得钥匙的过程可是需要一些功夫的，因为老换锁啊，每7200s换一次，所以有位管理员大爷出现了，就是<code>refresh_token</code>，锁换了找大爷拿把新的就行。那么这个管理员大爷怎么找到的呢？是在第一次授权成功后会通过参数返回给你的一个<code>authorization_code</code>这个相当于是地图，能让你第一次在毫无经验的情况下找到第一把钥匙和管理员大爷，也就是官方文档的第4步。</p></li><li><p>想要找到地图，给公众平台的管理员发个链接吧<code>https://mp.weixin.qq.com/cgi-bin/componentloginpage?component_appid=xxxx&amp;pre_auth_code=xxxxx&amp;redirect_uri=xxxx</code>，redirect_uri就是把<code>authorization_code</code>给你的入口。例如你写的是<code>redirect_uri=mydomain.com/authrize/callback</code>，那么一旦授权成功，浏览器就会跳转到<code>mydomain.com/authrize/callback?auth_code=xxxx</code>上来，你就可以获取<code>authorization_code</code>这个地图了。</p></li><li><p>上一步的链接中有一个pre_auth_code那么这个值怎么来的？是通过<code>api_create_preauthcode</code>这个接口获得的。而调用这个接口又需要<code>component_access_token</code>，这个东东就是一个令牌，你作为第三方平台调用微信任何API都必须有这个令牌，获得这个令牌的办法就是用调用<code>api_component_token</code>通过<code>component_verify_ticket</code>去换。（仔细想一想，其实<code>component_verify_ticket</code>=<code>refresh_token</code>, <code>component_access_token</code>=<code>accessToken</code>）</p></li></ol><p>这里面涉及到的变量很多，特别需要注意一些的：</p><ul><li><code>component_verify_ticket</code> 这张门票是微信推送，大概每隔十分钟推一次。</li><li><code>api_component_token</code>刚才说了是用上面的那张门票换的，但是有保质期，2小时，那么能不能每次要调接口都用门票换一下？人家微信是有每天的接口调用次数限定的，所以建议用个cache缓存起来，到了1小时50分的时候让缓存失效，失效再去call API换。可以用<strong>redis</strong>的TTL实现。</li><li>类比的上文第1步提到的公众号的<code>accessToken</code>也是有保质期的，所以一定要保存好对应的<code>refresh_token</code>，到了1小时50分的时候再去换<code>accessToken</code>。</li></ul><p>一旦拿到公众号的<code>accessToken</code>，那么就可以像普通公众号的后台服务那样，比如获取粉丝列表啊，推送文章图片啊等等。</p><p>PS: 最好采用加解密算法来进行消息的接受和推送。这里面有一个坑:</p><blockquote><p>异常java.security.InvalidKeyException:illegal Key Size的解决方案：在官方网站下载JCE无限制权限策略文件</p></blockquote><p>另外根据<a href="http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html" target="_blank" rel="noopener">官网提示</a>首次验证服务器地址的有效性，必须返回同样的<code>echostr</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信火了这么久，这两周第一次从一个开发者的角度来研究微信的生态系统而不是应用本身。现在做国内的项目或者产品难免都需要集成微信，其实现在微信背后的支撑平台已经是非常繁杂的了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公众平台（订阅号、服务号、企业号、小程序）&lt;/li&gt;
&lt;li&gt;开放平台（网页应用、移动应用、公众号第三方平台开发）&lt;/li&gt;
&lt;li&gt;商户平台 （支付）&lt;/li&gt;
&lt;li&gt;服务商平台（代支付）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.deanwangpro.com/tags/Java/"/>
    
      <category term="wechat" scheme="http://www.deanwangpro.com/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现机制</title>
    <link href="http://www.deanwangpro.com/2017/02/08/aop-in-java/"/>
    <id>http://www.deanwangpro.com/2017/02/08/aop-in-java/</id>
    <published>2017-02-07T16:00:00.000Z</published>
    <updated>2017-02-08T16:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。</p><a id="more"></a><p>静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</p><p>我们分别通过实例来研究AOP的具体实现。</p><h4 id="直接使用Spring-AOP"><a href="#直接使用Spring-AOP" class="headerlink" title="直接使用Spring AOP"></a>直接使用Spring AOP</h4><p>首先定义需要切入的接口和实现。为了简单起见，定义一个<code>Speakable</code>接口和一个具体的实现类，只有两个方法<code>sayHi()</code>和<code>sayBye()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSpring</span> <span class="keyword">implements</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们希望实现一个记录<code>sayHi()</code>和<code>sayBye()</code>执行时间的功能。</p><p>定义一个<code>MethodMonitor</code>类用来记录Method执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodMonitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodMonitor</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        System.out.println(<span class="string">"begin monitor.."</span>);</span><br><span class="line">        <span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(<span class="string">"end monitor.."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Method: "</span> + method + <span class="string">", execution time: "</span> + elapsedTime + <span class="string">" milliseconds."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光有这个类还是不够的，希望有个静态方法用起来更顺手，像这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MonitorSession.begin();</span><br><span class="line">doWork();</span><br><span class="line">MonitorSession.end();</span><br></pre></td></tr></table></figure><p>说干就干，定义一个<code>MonitorSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MethodMonitor&gt; monitorThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        MethodMonitor logger = <span class="keyword">new</span> MethodMonitor(method);</span><br><span class="line">        monitorThreadLocal.set(logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodMonitor logger = monitorThreadLocal.get();</span><br><span class="line">        logger.log();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万事具备，接下来只需要我们做好切面的编码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution (* com.deanwangpro.aop.service.Speakable.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(pjp.getSignature().getName());</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用？我用了spring boot，写一个启动函数吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Speakable personSpring;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">            <span class="comment">// spring aop</span></span><br><span class="line">            System.out.println(<span class="string">"******** spring aop ******** "</span>);</span><br><span class="line">            personSpring.sayHi();</span><br><span class="line">            personSpring.sayBye();</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">******** jdk dynamic proxy ******** </span><br><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 22 milliseconds.</span><br></pre></td></tr></table></figure></p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>刚刚的例子其实内部实现机制就是JDK动态代理，因为Person实现了一个接口。</p><p>为了不和第一个例子冲突，我们再定义一个<code>Person</code>来实现<code>Speakable</code>, 这个实现是不带Spring Annotation的，所以他不会被Spring托管。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Speakable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重头戏来了，我们需要利用<code>InvocationHandler</code>实现一个代理，让它去包含<code>Person</code>这个对象。那么再运行期实际上是执行这个代理的方法，然后代理再去执行真正的方法。所以我们得以在执行真正方法的前后做一些手脚。JDK动态代理是利用反射实现，直接看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0, Method arg1, Object[] arg2)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(arg1.getName());</span><br><span class="line">        Object obj = arg1.invoke(target, arg2);</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>getProxy</code>可以得到这个代理对象，<code>invoke</code>就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。</p><p>我实现了一个工厂类来获取Person代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Speakable <span class="title">newJdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代理PersonImpl</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> PersonImpl());</span><br><span class="line">        Speakable proxy = dynamicProxy.getProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// jdk dynamic proxy</span></span><br><span class="line">System.out.println(<span class="string">"******** jdk dynamic proxy ******** "</span>);</span><br><span class="line">Speakable jdkProxy = PersonProxyFactory.newJdkProxy();</span><br><span class="line">jdkProxy.sayHi();</span><br><span class="line">jdkProxy.sayBye();</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">******** jdk dynamic proxy ******** </span><br><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 22 milliseconds.</span><br></pre></td></tr></table></figure><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>我们再新建一个<code>Person</code>来，这次不实现任何接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Hi!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Bye!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Spring识别到所代理的类没有实现Interface，那么就会使用CGLib来创建动态代理，原理实际上成为所代理类的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CGLibProxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CGLibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLibProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span>  &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2,</span></span></span><br><span class="line"><span class="function"><span class="params">                            MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorSession.begin(arg1.getName());</span><br><span class="line">        Object obj = arg3.invokeSuper(arg0, arg2);</span><br><span class="line">        MonitorSession.end();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的通过<code>getProxy</code>可以得到这个代理对象，<code>intercept</code>就是具体的执行方法，可以看到我们在执行每个真正的方法前后都加了Monitor。</p><p>在工厂类中增加获得Person代理类的方法,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">newCglibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CGLibProxy cglibProxy = CGLibProxy.getInstance();</span><br><span class="line">    Person proxy = cglibProxy.getProxy(Person.class);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cglib dynamic proxy</span></span><br><span class="line">System.out.println(<span class="string">"******** cglib proxy ******** "</span>);</span><br><span class="line">Person cglibProxy = PersonProxyFactory.newCglibProxy();</span><br><span class="line">cglibProxy.sayHi();</span><br><span class="line">cglibProxy.sayBye();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin monitor..</span><br><span class="line">Hi!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayHi, execution time: 53 milliseconds.</span><br><span class="line">begin monitor..</span><br><span class="line">Bye!!</span><br><span class="line">end monitor..</span><br><span class="line">Method: sayBye, execution time: 14 milliseconds.</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对比JDK动态代理和CGLib代理，在实际使用中发现CGLib在创建代理对象时所花费的时间却比JDK动态代理要长，实测数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method: newJdkProxy, execution time: 5 milliseconds.</span><br><span class="line">Method: newCglibProxy, execution time: 18 milliseconds.</span><br></pre></td></tr></table></figure><p>所以CGLib更适合代理不需要频繁实例化的类。</p><p>在具体方法执行效率方面，理应是不通过反射的CGlib更快一些，然后测试结果并非如此，还需要高手指教。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JDK</span><br><span class="line">Method: sayHi, execution time: 32 milliseconds.</span><br><span class="line">CGLib</span><br><span class="line">Method: sayHi, execution time: 53 milliseconds.</span><br></pre></td></tr></table></figure><p>以上code都可以通过<a href="https://github.com/deanwong/aop-study" target="_blank" rel="noopener">Github</a>中获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AOP（Aspect Orient Programming），一般称为面向切面编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。静态代理是编译期实现，动态代理是运行期实现，可想而知前者拥有更好的性能。本文主要介绍Spring AOP的两种代理实现机制，JDK动态代理和CGLIB动态代理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.deanwangpro.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.deanwangpro.com/tags/Spring/"/>
    
      <category term="aop" scheme="http://www.deanwangpro.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>阿里电面试题汇总</title>
    <link href="http://www.deanwangpro.com/2017/01/31/ali-interview/"/>
    <id>http://www.deanwangpro.com/2017/01/31/ali-interview/</id>
    <published>2017-01-30T16:00:00.000Z</published>
    <updated>2017-01-31T15:30:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>年前意外的经历了一次阿里的电话面试，话说还没想换工作，但这位业余HR（应该是技术负责人）都没介绍工作岗位和要求，直接就约定某晚的电面时间，抱着好奇的态度被“虐”了一把。</p><p>总体感觉这位面试官问的问题非常深，基本都是系统或者原理级别的。不知道是不是代表了阿里面试的基本思路。</p><a id="more"></a><h4 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h4><p>内存空间（Runtime Data Area）中可以按照是否线程共享分成两块，线程共享的是方法区（Method Area）和堆（Heap），线程独享的是Java栈（Java Stack），本地方法栈（Native Method Stack）和PC寄存器（Program Counter Register）。</p><p>当然从1.8开始有一些变化，按照我的理解，原来常量池等信息都储存方法区，现在都移到堆里了。</p><blockquote><p>1.8中-XX:PermSize 和 -XX:MaxPermSize 已经失效，取而代之的是一个新的区域 —— Metaspace（元数据区）。</p></blockquote><blockquote><p>在 JDK 1.7 及以往的 JDK 版本中，Java 类信息、常量池、静态变量都存储在 Perm（永久代）里。类的元数据和静态变量在类加载的时候分配到 Perm，当类被卸载的时候垃圾收集器从 Perm 处理掉类的元数据和静态变量。当然常量池的东西也会在 Perm 垃圾收集的时候进行处理。</p></blockquote><blockquote><p>JDK 1.8 的对 JVM 架构的改造将类元数据放到本地内存中，另外，将常量池和静态变量放到 Java 堆里。HotSopt VM 将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来 -XX:MaxPermSize 的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类的造成经常 Full GC 问题，如运行时使用反射、代理等。</p></blockquote><p>所以升级以后Java堆空间可能会增加。</p><h4 id="http1-0，http1-1，http2-0区别"><a href="#http1-0，http1-1，http2-0区别" class="headerlink" title="http1.0，http1.1，http2.0区别"></a>http1.0，http1.1，http2.0区别</h4><p>说实话没有接触过1.0，只知道跟1.0相比1.1可以一次传输多个文件，各类浏览器大概都支持3~5个请求同时发送。</p><p>http2.0也是最近调Nginx才知道的一些，主要就是二进制的格式替代了原来的文本。后来查了资料大概知道增加了多路复用和首部压缩解决了head of line blocking，另外还有server pushing等新特性。协议的东西还是要看一看官网的说明，不过这东西过一段就容易忘。</p><h4 id="Get-Post对缓存的影响"><a href="#Get-Post对缓存的影响" class="headerlink" title="Get/Post对缓存的影响"></a>Get/Post对缓存的影响</h4><p>这题我一直没Get到点，意图其实是问浏览器缓存对于HTTP Method中Get和Post的请求是否支持，答案就是不支持Post Method。Get可以被浏览器缓存。</p><h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><p>这题其实我没法答，问的太大，大概瞥过V8的一些机制。比如构建Dom，生成CSS Rule等等。但是真实没有特别系统的理解过。</p><h4 id="mysql的Join原理以及索引数据结构和实现原理"><a href="#mysql的Join原理以及索引数据结构和实现原理" class="headerlink" title="mysql的Join原理以及索引数据结构和实现原理"></a>mysql的Join原理以及索引数据结构和实现原理</h4><p>只知道mysql innoDB join只支持Nested Loop，不支持Hash Join，就是确定一个驱动表后不断Join得到结果集，再继续往下Join。所以Join的顺序很重要。</p><p>索引只知道数据结构是B+Tree，其实就真悲催了。所以检讨一下，搜到一篇不错的<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">文章</a>。</p><h4 id="浏览器meta-charset和response中content-type的优先级"><a href="#浏览器meta-charset和response中content-type的优先级" class="headerlink" title="浏览器meta charset和response中content-type的优先级"></a>浏览器meta charset和response中content-type的优先级</h4><p>这题也是懵了，其实应该回想一下这一句，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>简写才是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>http-equiv 这个属性就是对应 HTTP response headers 里面的项目，其初衷是让不能（比如没有权限）设定服务器 header 的站点可以通过它来告知浏览器一些页面内容的相关信息。</p><p>了解以上就知道肯定是后者的优先级更高。</p><p>总结一下，裸面被虐残，阿里的面试官绝对是技术大拿，一言不合就问原理，触及灵魂了。反省自己还是应用做的太多，协议啊操作系统啊还是忘得快，没有系统的理解。以后还是应该多温故知新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年前意外的经历了一次阿里的电话面试，话说还没想换工作，但这位业余HR（应该是技术负责人）都没介绍工作岗位和要求，直接就约定某晚的电面时间，抱着好奇的态度被“虐”了一把。&lt;/p&gt;
&lt;p&gt;总体感觉这位面试官问的问题非常深，基本都是系统或者原理级别的。不知道是不是代表了阿里面试的基本思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://www.deanwangpro.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蜕变的2016</title>
    <link href="http://www.deanwangpro.com/2016/12/30/2016-summary/"/>
    <id>http://www.deanwangpro.com/2016/12/30/2016-summary/</id>
    <published>2016-12-29T16:00:00.000Z</published>
    <updated>2017-01-06T15:27:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2016年的倒数第二天，仿佛踮起脚就能够到17年。16年对于我来说是不平凡的一年，即使在暮年回首想必也会历历在目。</p><a id="more"></a><h3 id="孩子"><a href="#孩子" class="headerlink" title="孩子"></a>孩子</h3><p>最大的蜕变就是身份升级成了父亲，老婆从1月怀孕经历艰难的十月怀胎，终于在10月产下一个胖小子。这是全家最大的欢乐，即便有一些磕磕碰碰，但随着这个孩子的降临，一切都有了新的希望。感谢老婆，岳母岳母，爸妈对孩子的悉心照顾。自己也有了新的责任感，陪伴孩子的几个月真的是这一辈子最难忘也最怀念的时光。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>工作一直还算比较安定和自由，有一定的自主权选择自己喜欢的方向做一些东西。最打的收获应该说是全方位的体验了一次微服务的洗礼。一个既存系统从mono到拆成20多个小的service，期间经历了林林种种的问题，大约花费了半年的时间总算稳定下来。所以微服务给我最大的感受就是，这真不是一般公司可以玩儿的起的。对于架构师，甚至一线程序员的要求都高出不少。devops文化，API设计的规范，性能优化的能力等等都得具备。</p><p>接触到技术或者床架主要是kubernetes，和spring-boot提供一系列微服务方案，其中包含了netflix的各类组件比如hytrix。如果用spring-boot从无到有的构建一个微服务，在官网上已经给出了<a href="https://spring.io/blog/2015/07/14/microservices-with-spring" target="_blank" rel="noopener">答案</a>，而且Github上的脚手架也是不少。</p><p>微服务之间的通信除了API的直接通信，更多的是一种基于消息的异步通信，好处是提高throughput，16年大约有4个月的时间我都在研究基于消息的数据同步存储。也写了几篇浅见发在自己的博客上。这个<a href="http://www.deanwangpro.com/">博客</a>也是今年刚刚上线，一开始是jekyll的，后来转到hexo，托管在Github。有了技术博客，有个很大的好处是一旦有一些技术发现就想纪录下来，并且写的过程也是一个揣摩再消化的过程。明年希望能够保持一周到两周一篇的更新频率。</p><p>工作之外接触最多的技术还就是docker了，再加上玩儿了WordPress一两年了，所以也利用compose搞了一个WordPress的开发环境，大概是这样的配置<code>nginx-apline + php7-fpm-alpine + mariadb + wordpress 4.6</code></p><h3 id="财务"><a href="#财务" class="headerlink" title="财务"></a>财务</h3><p>结婚以后家里柴米油盐都是花销，从08年我就有记账的习惯，保持至今。今年家里添丁，花销自然是不少，所以最后结果仅仅是略有盈余，但是明年还需要买车位装修，交契税，更大的花销还在17年。</p><ul><li>最大的开支是车位预支了3w定金</li><li>保险花费了1.6w，这一项比较固定，今年新增加了宝宝的保险</li><li>养车1.2w</li><li>生宝宝医院费用 + 月嫂 + 各种育儿用品2w</li><li>家里水电宽带各种新添置的电器等等共计1.5w</li><li>平时吃饭包括聚会什么的共计1w</li><li>其余手机费，买衣服，看演出等费用非常低，大约0.5w左右，可见今年养孩子真是没有娱乐活动的。</li></ul><p>综上，一年花销在11w左右，财务状况还是挺正常的，开源节流看来没有必要，还是想想怎么多赚钱好了。</p><h3 id="愿望"><a href="#愿望" class="headerlink" title="愿望"></a>愿望</h3><ul><li>多多跟孩子在一起，真的不像错过儿子任何一个成长的瞬间。</li><li>磨炼技艺，多赚钱，真想再深挖一下WordPress的潜力。</li><li>坚持更新技术博客，二三周一遍的频率。</li><li>坚持夜跑，每天2~3公里。</li><li>坚持看书，一周3~4小时。</li><li>坚持练习口语，一周3~4小时。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2016年的倒数第二天，仿佛踮起脚就能够到17年。16年对于我来说是不平凡的一年，即使在暮年回首想必也会历历在目。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用JPA实现消息落地的一些问题</title>
    <link href="http://www.deanwangpro.com/2016/12/25/jpa-and-spring-retry/"/>
    <id>http://www.deanwangpro.com/2016/12/25/jpa-and-spring-retry/</id>
    <published>2016-12-24T16:00:00.000Z</published>
    <updated>2017-03-22T14:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前我们处理消息的同步，一般是落地到DB后，再同过异步的方式做数据的聚合和处理。至于DB的操作为了简单直接用了Hibernate提供的一套JPA接口，（老实说真的是不喜欢JPA，一是sql log不好分析无法优化，二是必须非常了解JPA的所有关键字含义，不然就要出问题，所以我一直喜欢用mybatis这种更轻量的甚至spring-jdbc）。</p><p>那么使用JPA的过程就遇到了一些问题，见招拆招一件一件来。</p><a id="more"></a><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>遇到的第一个问题就非常的要命，我们的系统是一张单表需要支持multi-tenant多租户，简单说就是表中有个tenantId的字段来区分租户，这是比较常见的设计。那么在对DB做操作的时候，ORM框架应该提供分租户的CURD接口，而不需要开发人员都自己在<code>where</code>中加<code>tenantId=***</code>。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>这个问题其实没有解决，因为Hibernate还没有实现单表的Multi-tenant（真是相当的坑）。<a href="https://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html/ch16.html" target="_blank" rel="noopener">官网文档</a>中说了这样三种情况</p><blockquote><p>SCHEMA<br>Correlates to the separate schema approach. It is an error to attempt to open a session without a tenant identifier using this strategy. Additionally, a MultiTenantConnectionProvider must be specified.</p></blockquote><blockquote><p>DATABASE<br>Correlates to the separate database approach. It is an error to attempt to open a session without a tenant identifier using this strategy. Additionally, a MultiTenantConnectionProvider must be specified.</p></blockquote><blockquote><p>DISCRIMINATOR<br>Correlates to the partitioned (discriminator) approach. It is an error to attempt to open a session without a tenant identifier using this strategy. This strategy is not yet implemented in Hibernate as of 4.0 and 4.1. Its support is planned for 5.0.</p></blockquote><p>可以看到最后一种还不支持呢。没办法只有手写where啦。</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>由于是处理消息，即使收到DELETE的message也不能真的删除，因为消息是<strong>乱序</strong>的，如果先来了DELETE再来UPDATE怎么办，实际上是先UPDATE再DELETE，但由于处理效率不一致，所以收到的消息顺序也是无法确定的。基于这点，为了保证数据的最终一致性，所以操作都作为UPDATE处理。删除操作必须是<strong>soft delete</strong></p><h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>可以写一个BaseEntity，都有isactive这个字段，默认都是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name=<span class="string">"isactive"</span>, columnDefinition=<span class="string">"boolean DEFAULT true"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean active = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActive</span><span class="params">(Boolean active)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.active = active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后继承一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance</span>(strategy = InheritanceType.JOINED)</span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"Product"</span>)</span><br><span class="line"><span class="meta">@Where</span>(clause=<span class="string">"isactive = 1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注意<code>@Where</code>就是所有操作都会拼上这个condition从而实现soft delete。</p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>在处理类似外键关联这种数据的时候，例如Product上有个CategoryId字段，那么数据库设计是一张Category表，一张Product表，Product表上CategoryId字段作为外键关联到Category表的ID字段。那么作为一个JPA的Entity，大家知道Entity是OO的，Product Entity下应该包含一个Category Entity，关系是oneToMany的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span>(fetch = FetchType.EAGER)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"categoryId"</span>)</span><br><span class="line"><span class="keyword">private</span> CategoryEntity category;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这里要插一句，其实如果只是把Category当普通字段，存一个CategoryId也是没有问题的，但是在查询的时候就需要用这个Product.CategoryId再去Category里查一次。用了JPA之后，为了减少一次查询，有时候事情反而会复杂）。</p><p>至于消息，比如先收到Product的CREATE事件，这时候会拿消息体里的categoryId去category表查一下有没有这个Category Entity，如果有直接得到后塞到Product的Category属性上去，但是如果没有这个Category怎么办？</p><h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>如果没有的话，按照JPA的外键关联原则，我们需要建立一个虚拟的Category，也就是说插入一条占位数据到Category表中，只有ID有值。所以对ProductEntity做些改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEntity</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span>(cascade = &#123;CascadeType.PERSIST&#125;, fetch = FetchType.EAGER)</span><br><span class="line"><span class="meta">@NotFound</span>(action= NotFoundAction.IGNORE)</span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"categoryId"</span>)</span><br><span class="line"><span class="keyword">private</span> CategoryEntity category;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意加了两点，一是<code>cascade = {CascadeType.PERSIST}</code>，意思是如果Persist了Product的话，发现categoryId不为空而category表中又没有该Category，那么级联插入这条数据（只有ID）。二是<code>@NotFound(action= NotFoundAction.IGNORE)</code>，加这条是防止当收到一个Category.DELETE事件后软删除了Category，而读取Product的时候就会Eager地获得Category，一旦获取不到JPA会抛出<code>EntityNotExist</code>的异常。加了这个注解，Product里的category就为null，不会出异常。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>这实际上是问题3的衍生，解决3的时候我们使用了<code>Cascade=PERSIST</code>，那么在发现Category不存在的时候，JPA会发起一个insert，当然数据只有ID，其他的字段等待真正的Category的CREATE事件来了再填充。但是并发的问题就出现了，如果正好就在发起insert之前，Category的CREATE事件来了（另一个Worker在处理），那里也发现表里没有这个Category，所以也随即发起一个insert操作。conflict就这样发生了，主键冲突！这时候怎么办？</p><h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>我采取了一种比较粗暴的方式，就是retry，首先每次收到事件后的写操作，都是查Entity是否存在，存在就Update，不存在就Insert。当两个Worker同时做写入操作，肯定一个成功一个失败，失败的只要retry一次就会发现Entity有了（另一个Worker写入的），这时候变成Update操作就不会有conflict。</p><p>因为项目中依赖Spring，所以恰好有了spring-retry这个包，直接用起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTemplateBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> RetryTemplate buildable;</span><br><span class="line">    <span class="keyword">protected</span> RetryTemplateBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buildable = createBuildable();</span><br><span class="line">        builder = getBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetryTemplateBuilder <span class="title">retryTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RetryTemplateBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RetryTemplateBuilder <span class="title">withPolicies</span><span class="params">(RetryPolicy... policies)</span> </span>&#123;</span><br><span class="line">        CompositeRetryPolicy compositePolicy = <span class="keyword">new</span> CompositeRetryPolicy();</span><br><span class="line">        compositePolicy.setPolicies(policies);</span><br><span class="line">        buildable.setRetryPolicy(compositePolicy);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RetryTemplateBuilder <span class="title">withPolicies</span><span class="params">(RetryPolicy retryPolicy, BackOffPolicy backOffPolicy)</span> </span>&#123;</span><br><span class="line">        buildable.setRetryPolicy(retryPolicy);</span><br><span class="line">        buildable.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RetryTemplateBuilder <span class="title">withPolicies</span><span class="params">(BackOffPolicy backOffPolicy)</span> </span>&#123;</span><br><span class="line">        buildable.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RetryTemplate <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RetryTemplate <span class="title">createBuildable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RetryTemplateBuilder <span class="title">getBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个TemplateBuilder，可以理解成retry的模板，一个retryTemplate可以包含多个policy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRetryPolicyBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SimpleRetryPolicy buildable;</span><br><span class="line">    <span class="keyword">protected</span> SimpleRetryPolicyBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRetryPolicyBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buildable = createBuildable();</span><br><span class="line">        builder = getBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleRetryPolicyBuilder <span class="title">simpleRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryPolicyBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleRetryPolicy <span class="title">simpleRetryPolicyWithRetryableExceptions</span><span class="params">(<span class="keyword">int</span> maxAttempts,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                             Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryPolicy(maxAttempts, exception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRetryPolicyBuilder <span class="title">withMaxAttempts</span><span class="params">(<span class="keyword">int</span> maxAttempts)</span> </span>&#123;</span><br><span class="line">        buildable.setMaxAttempts(maxAttempts);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRetryPolicy <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleRetryPolicy <span class="title">createBuildable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleRetryPolicyBuilder <span class="title">getBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这种Policy，就是可以定义需要重试几次，在哪些异常发生的时候重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedBackOffPolicyBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> FixedBackOffPolicy buildable;</span><br><span class="line">    <span class="keyword">protected</span> FixedBackOffPolicyBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FixedBackOffPolicyBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buildable = createBuildable();</span><br><span class="line">        builder = getBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FixedBackOffPolicyBuilder <span class="title">fixedBackOffPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FixedBackOffPolicyBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FixedBackOffPolicyBuilder <span class="title">withDelay</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">        buildable.setBackOffPeriod(delay);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FixedBackOffPolicy <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FixedBackOffPolicy <span class="title">createBuildable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FixedBackOffPolicyBuilder <span class="title">getBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有这种可以定义retry的间隔时间。</p><p>最后用起来就手到擒来了，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; retryFor = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 定义两种异常发生时retry</span></span><br><span class="line">retryFor.put(DataIntegrityViolationException.class, Boolean.TRUE);</span><br><span class="line">retryFor.put(ConstraintViolationException.class, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 定义最大retry次数和间隔时间</span></span><br><span class="line">RetryTemplate retryTemplate = RetryTemplateBuilder.retryTemplate()</span><br><span class="line">        .withPolicies(</span><br><span class="line">                SimpleRetryPolicyBuilder.simpleRetryPolicyWithRetryableExceptions(MAX_ATTEMPTS, retryFor),</span><br><span class="line">                FixedBackOffPolicyBuilder.fixedBackOffPolicy().withDelay(RETRY_DELAY).build())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">retryTemplate.execute(<span class="keyword">new</span> RetryCallback() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">doWithRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Attempt times ["</span> + context.getRetryCount() + <span class="string">"]"</span>);</span><br><span class="line">        <span class="comment">// Your logic code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在生产环境测试，99%的情况一次retry就可以解决问题，所以我的经验值是设置了3次最大重试次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前我们处理消息的同步，一般是落地到DB后，再同过异步的方式做数据的聚合和处理。至于DB的操作为了简单直接用了Hibernate提供的一套JPA接口，（老实说真的是不喜欢JPA，一是sql log不好分析无法优化，二是必须非常了解JPA的所有关键字含义，不然就要出问题，所以我一直喜欢用mybatis这种更轻量的甚至spring-jdbc）。&lt;/p&gt;
&lt;p&gt;那么使用JPA的过程就遇到了一些问题，见招拆招一件一件来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://www.deanwangpro.com/tags/MQ/"/>
    
      <category term="JPA，Spring" scheme="http://www.deanwangpro.com/tags/JPA%EF%BC%8CSpring/"/>
    
  </entry>
  
  <entry>
    <title>解决jenkins中npm install的symlink问题</title>
    <link href="http://www.deanwangpro.com/2016/12/16/jenkins-npm-symlink-issue/"/>
    <id>http://www.deanwangpro.com/2016/12/16/jenkins-npm-symlink-issue/</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2016-12-19T16:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这一周在Jenkins上跑npm install经常会出现build fail，查了日志就是下面输出的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! node v4.4.7</span><br><span class="line">npm ERR! npm  v2.15.8</span><br><span class="line">npm ERR! path ../gulp/bin/gulp.js</span><br><span class="line">npm ERR! code EEXIST</span><br><span class="line">npm ERR! errno -17</span><br><span class="line">npm ERR! syscall symlink</span><br><span class="line"></span><br><span class="line">npm ERR! EEXIST: file already exists, symlink &apos;../gulp/bin/gulp.js&apos; -&gt; &apos;/.jenkins/workspace/eshop/build/node_modules/.bin/gulp&apos;</span><br><span class="line">File exists: ../gulp/bin/gulp.js</span><br><span class="line">Move it away, and try again. </span><br><span class="line"></span><br><span class="line">npm ERR! Please include the following file with any support request:</span><br><span class="line">npm ERR!    /.jenkins/workspace/eshop/build/npm-debug.log</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 19.399 s</span><br><span class="line">[INFO] Finished at: 2016-12-15T06:06:26+00:00</span><br><span class="line">[INFO] Final Memory: 8M/63M</span><br><span class="line">[INFO] -----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>一开始以为是建symlink的问题，考虑了可能权限或者symlink已存在的情况。但是用全新的一个虚机去跑npm install还是失败，错误有原因也是一样。本着死马当活马医的思路，加了一个<code>-–no-bin-link</code>参数，问题奇迹的解决了。查看官网的一段解释<code>The --no-bin-links argument will prevent npm from creating symlinks for any binaries the package might contain.</code>貌似也是在虚机才会出现这种情况。</p><p>之后又咨询了我们做构建的同事，他们建议把nodejs升级到6，同样也解决了问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看来root cause是查不到了，只能给两个建议</p><ol><li>加<code>-–no-bin-link</code>参数</li><li>升级Jenkins机器上的nodejs版本到6</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;这一周在Jenkins上跑npm install经常会出现build fail，查了日志就是下面输出的样子：&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.deanwangpro.com/tags/Javascript/"/>
    
      <category term="npm" scheme="http://www.deanwangpro.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>如何处理有依赖的消息</title>
    <link href="http://www.deanwangpro.com/2016/12/01/how-to-handle-dependency-message/"/>
    <id>http://www.deanwangpro.com/2016/12/01/how-to-handle-dependency-message/</id>
    <published>2016-11-30T16:00:00.000Z</published>
    <updated>2016-12-01T16:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中踏完一系列坑后总结出来，消息的处理有两个要务：</p><ol><li>消费一定要快，我们喜欢供小于求的市场。生产者生产的消息要满足不了消费者才行。</li><li>任何消息都不能丢，因为这都是数据啊，即使处理不了也得找地方存着。最好每次的消息都存着，之后就变成了event sourcing（另一个大坑）。</li></ol><a id="more"></a><p>要实现上述2点，其实要解决很多问题。一个<strong>快</strong>字就不是那么做到的。业务系统收到消息有可能会触发一连串的，并且包裹着<strong>事务</strong>的逻辑。因为通常我们希望如果这一连串的处理失败的话，可以把ack退回给MQ。一旦业务逻辑过于复杂，work消费消息的速度也会变慢。这就需要开发人员去做权衡了，是不是有些非常heavy的操作可以先记一笔，等业务不繁忙的时候再做。具体实现不在这篇讨论。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>回到主题，有一类消息最让人头疼，就是消息之间有依赖，关系一般为单向的父子关系。举个栗子，Product和SKU的关系，一个Product包含多个SKU。比如我们的业务逻辑是要监听这两个消息组成一颗树放到索引中。可想而知，这棵树肯定是至少两层结构，第一级是Product，下面挂着一个或多个SKU。</p><p>一般来说，子结构如果是个单独的消息肯定会有个字段说明自己的parent id是什么。那么很自然的，我们在某一刻只收到一个SKU的Create事件，会去通过parent id找到索引中对应的Product，然后<strong>挂</strong>上去。问题来了，要是索引中没有对应的Product怎么办，消息是没有顺序的，可能是Product的Create事件还没处理到，或者是生产者出了bug消息没发出来造成的。这时SKU的消息就成了<strong>孤儿消息</strong>。</p><h3 id="解决思路一"><a href="#解决思路一" class="headerlink" title="解决思路一"></a>解决思路一</h3><p>比较近粗暴的方式，就是利用SKU上的parent id虚拟出一个只有id的Product，由处理SKU事件的worker来帮忙创建这个Product。等下次Product的Create消息进来做一次更新就好了。（处理消息应该不要区分这是Create还是Update还是Delete，消费者就都当Update来做比较好，可以想想为什么）。</p><p>当然这个思路一看就有点bad smell，从单一职责的角度上来看，处理SKU的worker应该只关注SKU，不应该关注Product。如果Product也是个<strong>孤儿</strong>怎么办呢？这个worker可能会越写越复杂。</p><p><del>改进的话可以把创建虚拟Product的这个事情放到SKU这个对象中去做，实现以下setProduct这个方法。那么即使Product也有依赖，那Product自己也得有个setParent的方法，这样就可以递归下去了。</del>(之后想了一下无法处理多级关系，因为Product的消息没来，我们不知道它的parent id，父节点根本建不出来。所以思路一只能处理一个层级的依赖。)</p><p>总结一下，<strong>思路一</strong>是一种不管三七二十一，谁也不能阻止我消费的路线，大不了自下而上的创建虚拟父节点。</p><h3 id="解决思路二"><a href="#解决思路二" class="headerlink" title="解决思路二"></a>解决思路二</h3><p>相对思路一而言，这种思路还是比较优雅的，但是优雅不等于性能好。</p><p>既然SKU是个<strong>孤儿</strong>，那么我们先收下来放<strong>孤儿院</strong>好了。新建一张<strong>孤儿院</strong>表：</p><table><thead><tr><th>id</th><th>parent_type</th><th>parent_id</th></tr></thead><tbody><tr><td>101010</td><td>Product</td><td>1010</td></tr><tr><td>101011</td><td>Product</td><td>1010</td></tr></tbody></table><p>上面两条数据就是SKU的，然后为了提升一点性能我们得对对象分个类，一类是有依赖的，一类是无依赖的。没有依赖的直接消费就好，像Product，SKU这种有依赖的，都得打上标签（就是对象里写个isDependency）。例如一个SKU(101010)的消息进来，worker发现这是一个有依赖的消息，那么先拿parent id (1010)去找Product, 发现Product找不到就把这个SKU丢到<strong>孤儿院</strong>表里去。如果你是用OO的语言，这里其实可以抽象一下。一个BaseWorker，一个SKUWorker，BaseWork负责写个abstract的findParent()，SKUWorker去实现找Product的逻辑就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseWorker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.isDependency() &amp;&amp; findParent(t) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 送到孤儿院</span></span><br><span class="line">            takeToOrphanage(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Entity <span class="title">findParent</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">takeToOrphanage</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息记录下来以后，Worker的工作就终止，等待下一条消息进来。过了几分钟，Product(1010)的消息过来了，这时候我们需要给BaseWorker再添加一些代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.isDependency() &amp;&amp; findParent(t) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 送到孤儿院</span></span><br><span class="line">            takeToOrphanage(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常业务...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常业务处理之后</span></span><br><span class="line">        <span class="keyword">if</span> (t.isDependency()) &#123;</span><br><span class="line">            List&lt;Entity&gt; children = findChildren(t);</span><br><span class="line">            <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                children.forEach(child -&gt; &#123;</span><br><span class="line">                    sendAsMessage(child);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> List&lt;Entity&gt; <span class="title">findChildren</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>我们增加一个findChildren方法，让ProductWorker去实现具体逻辑。handle()中增加的代码含义是，当Product这个消息消费完了以后，去<strong>孤儿院</strong>转一圈看看是不是有等待认领的孩子，简单的利用<code>parent_type</code>和<code>parent_id</code>就能查到。查到以后别直接处理，仍然是以消息的形式发出，让SKUWorker自己去handle，然后可以delete/soft-delete<strong>孤儿院</strong>中的记录。</p><p>可以看到一个有依赖的消息我们在处理的过程，会多一次查询操作，性能多少会受点影响。之前的那次findParent查询其实思路一也有的，目的就是挂靠。</p><p>再多一个层级看看是不是罩得住，<code>Category --&gt; Product --&gt; SKU</code> 三层。</p><p>如果没有Category的消息进来，孤儿院里是酱紫的。</p><table><thead><tr><th>id</th><th>parent_type</th><th>parent_id</th></tr></thead><tbody><tr><td>101010</td><td>Product</td><td>1010</td></tr><tr><td>101011</td><td>Product</td><td>1010</td></tr><tr><td>1010</td><td>Category</td><td>10</td></tr></tbody></table><p>某一时刻Category的消息进来，CategoryWorker会先到表里查到一条1010的Product消息，把它send出来。ProductWorker收到之后再处理，紧接着又找到SKU的2条消息，再send出来，让SKUWorker去处理。可以看到，自带递归，多层级只要是单向依赖的肯定搞的定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中踏完一系列坑后总结出来，消息的处理有两个要务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消费一定要快，我们喜欢供小于求的市场。生产者生产的消息要满足不了消费者才行。&lt;/li&gt;
&lt;li&gt;任何消息都不能丢，因为这都是数据啊，即使处理不了也得找地方存着。最好每次的消息都存着，之后就变成了event sourcing（另一个大坑）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.deanwangpro.com/tags/Java/"/>
    
      <category term="MQ" scheme="http://www.deanwangpro.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>How to count the number of set bits in ASCII string</title>
    <link href="http://www.deanwangpro.com/2016/11/14/asc-to-binary/"/>
    <id>http://www.deanwangpro.com/2016/11/14/asc-to-binary/</id>
    <published>2016-11-13T16:00:00.000Z</published>
    <updated>2017-03-22T14:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是最近看到的一个算法题，第一眼看过去连题目都看不懂啊囧。非计算机本科生表示对算法十分无力。第一直觉肯定是把ASCII的字符都换成int，然后题目就可以变成How to count the number of set bits in integer. google一下还真有<a href="How to count the number of set bits in ASCII string">答案</a>.第一个高分回答表示各种位操作都看不懂。传说中的<a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming_weight</a>算法。真是给跪了。</p><p>突然想到Java的Integer类本来就有个toBinaryString方法，再加上最近正好研究UUID生成，觉得用现成的方法实现一下。</p><a id="more"></a><p>直接贴源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASC2Bin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">asc2bin</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder binaryString = <span class="keyword">new</span> StringBuilder(<span class="number">8</span> * str.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ascInt = (<span class="keyword">int</span>) str.charAt(i);</span><br><span class="line">                StringBuilder temp = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(ascInt));</span><br><span class="line">                String bin = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp.length() &lt;= DEFAULT_LENGTH) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (temp.length() &lt; DEFAULT_LENGTH) &#123;</span><br><span class="line">                        temp.insert(<span class="number">0</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bin = temp.toString();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.length() &gt; DEFAULT_LENGTH) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                binaryString.append(bin);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binaryString.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bin2asc</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10010001100101 split into 8 characters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() - <span class="number">1</span>; i += DEFAULT_LENGTH) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//grab the hex in pairs</span></span><br><span class="line">            String output = str.substring(i, (i + DEFAULT_LENGTH));</span><br><span class="line">            <span class="comment">//convert hex to decimal</span></span><br><span class="line">            <span class="keyword">int</span> decimal = Integer.parseInt(output, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//convert the decimal to character</span></span><br><span class="line">            sb.append((<span class="keyword">char</span>) decimal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String binary = asc2bin(<span class="string">"Hello world!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"binary : "</span> + binary);</span><br><span class="line">        String asc = bin2asc(binary);</span><br><span class="line">        System.out.println(<span class="string">"ASC : "</span> + asc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实一开始的时候我并没有强制限定每一个ASCII字符都是8位bits，但是逆操作的时候遇到问题了。一般的ASCII字符在我本机CPU下的是7个bit，但是空格和其他符号都是6个bit。这个就比较麻烦了，不好直接按位数切分做逆操作。索性定死8位前面补0，方法比较土鳖，也没考虑性能（说实话我还真没那个本事），各位随便看看吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是最近看到的一个算法题，第一眼看过去连题目都看不懂啊囧。非计算机本科生表示对算法十分无力。第一直觉肯定是把ASCII的字符都换成int，然后题目就可以变成How to count the number of set bits in integer. google一下还真有&lt;a href=&quot;How to count the number of set bits in ASCII string&quot;&gt;答案&lt;/a&gt;.第一个高分回答表示各种位操作都看不懂。传说中的&lt;a href=&quot;http://en.wikipedia.org/wiki/Hamming_weight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hamming_weight&lt;/a&gt;算法。真是给跪了。&lt;/p&gt;
&lt;p&gt;突然想到Java的Integer类本来就有个toBinaryString方法，再加上最近正好研究UUID生成，觉得用现成的方法实现一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.deanwangpro.com/tags/Java/"/>
    
      <category term="algorithm" scheme="http://www.deanwangpro.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
